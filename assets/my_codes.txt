file 1: C:\coding\blackcobra-cpp\.gitignore
.venv/*

file 2: C:\coding\blackcobra-cpp\serial_monitor.py
import serial
import time

PORT = "COM3"
BAUD = 9600

try:
    with serial.Serial(PORT, BAUD, timeout=1) as ser:
        print(f"📡 Serial monitor aktif di {PORT} ({BAUD} baud)")
        while True:
            if ser.in_waiting:
                line = ser.readline().decode("utf-8", errors="ignore").strip()
                if line:
                    print(line)
            time.sleep(0.1)
except serial.SerialException as e:
    print(f"❌ Gagal membuka {PORT}:\n{e}")


file 3: C:\coding\blackcobra-cpp\upload.ps1
param (
    [string]$Sketch = "archives/milis",
    [string]$Board = "arduino:avr:mega",
    [string]$Port = "COM3"
)

Write-Host "[1/2] Compiling sketch: $Sketch"
arduino-cli compile --fqbn $Board $Sketch
if ($LASTEXITCODE -ne 0) {
    Write-Error "❌ Compile failed"
    exit $LASTEXITCODE
}

Write-Host "`n[2/2] Uploading to $Port..."
arduino-cli upload -p $Port --fqbn $Board $Sketch
if ($LASTEXITCODE -ne 0) {
    Write-Error "❌ Upload failed"
    exit $LASTEXITCODE
}

Write-Host "`n✅ Done."
pause


file 4: C:\coding\blackcobra-cpp\upload_gui.ps1
Add-Type -AssemblyName System.Windows.Forms
[System.Windows.Forms.Application]::EnableVisualStyles()

# --- GUI Form ---
$form = New-Object System.Windows.Forms.Form
$form.Text = "Arduino Uploader"
$form.Size = New-Object System.Drawing.Size(400,250)
$form.StartPosition = "CenterScreen"

# --- Label Sketch ---
$lblSketch = New-Object System.Windows.Forms.Label
$lblSketch.Text = "Nama folder sketch (misal: milis):"
$lblSketch.Location = New-Object System.Drawing.Point(10,20)
$lblSketch.Size = New-Object System.Drawing.Size(300,20)
$form.Controls.Add($lblSketch)

# --- Input Sketch ---
$txtSketch = New-Object System.Windows.Forms.TextBox
$txtSketch.Location = New-Object System.Drawing.Point(10,40)
$txtSketch.Size = New-Object System.Drawing.Size(360,20)
$txtSketch.Text = "archives/milis"
$form.Controls.Add($txtSketch)

# --- Label COM ---
$lblCOM = New-Object System.Windows.Forms.Label
$lblCOM.Text = "Port COM (misal: COM3):"
$lblCOM.Location = New-Object System.Drawing.Point(10,70)
$lblCOM.Size = New-Object System.Drawing.Size(300,20)
$form.Controls.Add($lblCOM)

# --- Input COM ---
$txtCOM = New-Object System.Windows.Forms.TextBox
$txtCOM.Location = New-Object System.Drawing.Point(10,90)
$txtCOM.Size = New-Object System.Drawing.Size(360,20)
$txtCOM.Text = "COM3"
$form.Controls.Add($txtCOM)

# --- Checkbox Serial Monitor ---
$chkMonitor = New-Object System.Windows.Forms.CheckBox
$chkMonitor.Text = "Buka Serial Monitor setelah upload"
$chkMonitor.Location = New-Object System.Drawing.Point(10,120)
$chkMonitor.Size = New-Object System.Drawing.Size(300,20)
$chkMonitor.Checked = $false
$form.Controls.Add($chkMonitor)

# --- Tombol Upload ---
$btnUpload = New-Object System.Windows.Forms.Button
$btnUpload.Text = "Compile & Upload"
$btnUpload.Location = New-Object System.Drawing.Point(10,160)
$btnUpload.Size = New-Object System.Drawing.Size(150,30)
$form.Controls.Add($btnUpload)

# --- Output Status ---
$output = New-Object System.Windows.Forms.Label
$output.Location = New-Object System.Drawing.Point(10,200)
$output.Size = New-Object System.Drawing.Size(360,20)
$form.Controls.Add($output)

# --- Aksi Upload ---
$btnUpload.Add_Click({
    $sketch = $txtSketch.Text
    $port = $txtCOM.Text
    $board = "arduino:avr:mega"

    $output.Text = "🛠 Compile..."
    $compile = Start-Process -FilePath "arduino-cli" -ArgumentList "compile --fqbn $board $sketch" -NoNewWindow -Wait -PassThru
    if ($compile.ExitCode -ne 0) {
        $output.Text = "❌ Compile gagal."
        return
    }

    $output.Text = "⬆️ Upload..."
    $upload = Start-Process -FilePath "arduino-cli" -ArgumentList "upload -p $port --fqbn $board $sketch" -NoNewWindow -Wait -PassThru
    if ($upload.ExitCode -ne 0) {
        $output.Text = "❌ Upload gagal."
        return
    }

    $output.Text = "✅ Selesai upload."

    if ($chkMonitor.Checked) {
        Start-Process -NoNewWindow -FilePath "arduino-cli" -ArgumentList "monitor -p $port -c baudrate=9600"
    }
})

# --- Tampilkan Form ---
$form.Topmost = $true
[void]$form.ShowDialog()


file 5: C:\coding\blackcobra-cpp\.vscode\naming_convetions.txt
Naming conventions by NWR:
1. Folder project : CAPITAL_WITH_UNDERSCORE
2. Sub folder : lowercase with space
3. Special folder : _underscore_begins_and_with_underscore
4. Code file name : CamelCase.extension
5. Common file name : lowercase_with_underscore.extension
5. Special file name : _underscore_begins_with_underscore.extension
6. Class : CamelCase
7. Variabel : snake_case
8. Unused variabel : _
9. Special variable : _underscore_begins
8. Constant : UPPERCASE_WITH_UNDERSCORE

folder in my sourcecode:
- src
- images
- videos
- data
- resources
- models
- run
- assets
- .vscode
- .venv


file 6: C:\coding\blackcobra-cpp\.vscode\settings.json
{
    "workbench.colorTheme": "Winter is Coming (Dark Blue)",
    "editor.fontSize": 14,
    "window.zoomLevel": 0,
    "editor.formatOnSave": true,
    "[python]": {
        "editor.defaultFormatter": "ms-python.black-formatter",
        "editor.formatOnSave": true
    },
    "black-formatter.args": [
        "--line-length=1000"
    ],
    "editor.autoIndent": "full",
    "editor.cursorBlinking": "smooth",
    "editor.cursorSmoothCaretAnimation": "on",
    "editor.cursorStyle": "line",
    "editor.fontFamily": "Dank Mono, Fira Code, Inconsolata",
    "editor.fontLigatures": true,
    "editor.formatOnPaste": true,
    "editor.formatOnType": false,
    "editor.letterSpacing": 0.3,
    "editor.lineHeight": 25,
    "editor.minimap.enabled": true,
    "editor.multiCursorModifier": "alt",
    "editor.suggestSelection": "first",
    "editor.tabCompletion": "on",
    "editor.tabSize": 2,
    "editor.wordWrap": "off",
    "files.autoSave": "afterDelay",
    "files.autoSaveDelay": 500,
    "search.showLineNumbers": true,
    "workbench.iconTheme": "material-icon-theme",
    "workbench.colorCustomizations": {
        "[Winter is Coming (Light)]": {
            "actionBar.toggledBackground": "#eeff00"
        }
    },
    "zenMode.centerLayout": false,
    "editor.find.autoFindInSelection": "always",
    "editor.minimap.autohide": true,
    "workbench.preferredDarkColorTheme": "Winter is Coming (Dark Blue)",
    "markdown.styles": [
        "https://use.fontawesome.com/releases/v5.7.1/css/all.css"
    ],
    "sqltools.connections": [
        {
            "mysqlOptions": {
                "authProtocol": "default",
                "enableSsl": "Disabled"
            },
            "previewLimit": 50,
            "server": "10.5.0.2",
            "port": 3307,
            "driver": "MySQL",
            "name": "10.5.0.2",
            "database": "report_ai_cctv",
            "username": "robot",
            "askForPassword": true
        },
        {
            "mysqlOptions": {
                "authProtocol": "default",
                "enableSsl": "Disabled"
            },
            "previewLimit": 50,
            "server": "localhost",
            "port": 3306,
            "driver": "MySQL",
            "name": "10.5.0.3",
            "database": "report_ai_cctv",
            "username": "root",
            "password": "robot123"
        }
    ]
}


file 7: C:\coding\blackcobra-cpp\.vscode\tasks.json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Compile & Upload Blink",
      "type": "shell",
      "command": "arduino-cli compile --fqbn arduino:avr:mega archives/blink && arduino-cli upload -p COM3 --fqbn arduino:avr:mega archives/blink",
      "options": {
        "shell": {
          "executable": "cmd.exe",
          "args": [
            "/c"
          ]
        }
      },
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "problemMatcher": []
    }
  ]
}

file 8: C:\coding\blackcobra-cpp\src\milis\milis.ino
const unsigned long INTERVAL = 1000;
unsigned long prevMillis     = 0;
bool           ledState      = false;

void setup() {
  Serial.begin(9600);
  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  Serial.println("Ini adalah milis src");
  unsigned long curMillis = millis();
  if (curMillis - prevMillis >= INTERVAL) {
    prevMillis = curMillis;
    ledState   = !ledState;
    digitalWrite(LED_BUILTIN, ledState);
  }
}


file 9: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\command.cpp
#include "command.h"
#include "logger.h"
#include <Arduino.h>

Command::Command() {
  //initialize Command to a zero-move value;
  new_command.valueX = NAN; 
  new_command.valueY = NAN;
  new_command.valueZ = NAN;
  new_command.valueF = 0;
  new_command.valueE = NAN;
  new_command.valueS = 0;
  message = "";
  isRelativeCoord = false;
}

bool Command::handleGcode() {
  if (Serial.available()) {
    char c = Serial.read();
    if (c == '\n') {
       return false; 
    }
    if (c == '\r') {
       bool success = processMessage(message);
       message = "";
       return success;  // Hanya kembalikan status, tidak kirim "ok" di sini
    } else {
       message += c; 
    }
  }
  return false;
}


bool Command::processMessage(String msg){

  // Tambahkan pengecekan untuk "VACUM ON" dan "VACUM OFF"
  if (msg.equalsIgnoreCase("VACUM ON")) {
    msg = "M209";
  } else if (msg.equalsIgnoreCase("VACUM OFF")) {
    msg = "M230";
  } else if (msg.equalsIgnoreCase("LG1 ON")) {
    msg = "M1";
  } else if (msg.equalsIgnoreCase("LG1 OFF")) {
    msg = "M2";
  } else if (msg.equalsIgnoreCase("LG2 ON")) {
    msg = "M206";
  } else if (msg.equalsIgnoreCase("LG2 OFF")) {
    msg = "M207";
  } else if (msg.equalsIgnoreCase("LG3 ON")) {
    msg = "M6";
  } else if (msg.equalsIgnoreCase("LG3 OFF")) {
    msg = "M7";
  }

  new_command.valueX = NAN; 
  new_command.valueY = NAN;
  new_command.valueZ = NAN;
  new_command.valueE = NAN;
  new_command.valueF = 0;
  new_command.valueS = 0;  
  msg.toUpperCase();
  msg.replace(" ", "");
  int active_index = 0;
  new_command.id = msg[active_index];
  if((new_command.id != 'G') && (new_command.id != 'M')){
    printErr();
    return false;
  }

  active_index++;
  int temp_index = active_index;
  while (temp_index<msg.length() && !isAlpha(msg[temp_index])){
    temp_index++;
  }
  new_command.num = msg.substring(active_index, temp_index).toInt();
  active_index = temp_index;
  temp_index++;
  while (temp_index<msg.length()){
    while (!isAlpha(msg[temp_index]) || msg[temp_index]=='.'){
      temp_index++;
      if (temp_index == msg.length()){
        break;
      }
    }
    value_segment(msg.substring(active_index, temp_index));
    active_index = temp_index;
    temp_index++;
  }
  return true;
}

void Command::value_segment(String msg_segment){
  float msg_value = msg_segment.substring(1).toFloat();
  switch (msg_segment[0]){
    case 'X': new_command.valueX = msg_value; break;
    case 'Y': new_command.valueY = msg_value; break;
    case 'Z': new_command.valueZ = msg_value; break;
    case 'E': new_command.valueE = msg_value; break;
    case 'F': new_command.valueF = msg_value; break;
    case 'S': new_command.valueS = msg_value; break;
    case 'A': new_command.valueA = msg_value; break; // Tambahkan ini
    case 'B': new_command.valueB = msg_value; break; // Tambahkan ini
  }
}


Cmd Command::getCmd() const {
  return new_command; 
}

void Command::cmdGetPosition(Point pos, Point pos_offset, float highRad, float lowRad, float rotRad){
  if(isRelativeCoord) {
    Logger::logINFO("RELATIVE MODE");
  } else {
    Logger::logINFO("ABSOLUTE MODE");
  }
  Logger::logINFO("CURRENT POSITION: [X:"+String(pos.xmm - pos_offset.xmm)+" Y:"+String(pos.ymm - pos_offset.ymm)+" Z:"+String(pos.zmm - pos_offset.zmm)+" E:"+String(pos.emm - pos_offset.emm)+"]");
  //Logger::logINFO("RADIANS: [HIGH:"+String(highRad)+" LOW:"+String(lowRad)+" ROT:"+String(rotRad));
}

void Command::cmdToRelative(){
  isRelativeCoord = true;
  Logger::logINFO("RELATIVE MODE ON");
}

void Command::cmdToAbsolute(){
  isRelativeCoord = false;
  Logger::logINFO("ABSOLUTE MODE ON");
}

void cmdMove(Cmd(&cmd), Point pos, Point pos_offset, bool isRelativeCoord){

  if(isRelativeCoord == true){
    cmd.valueX = isnan(cmd.valueX) ? pos.xmm : cmd.valueX + pos.xmm;
    cmd.valueY = isnan(cmd.valueY) ? pos.ymm : cmd.valueY + pos.ymm;
    cmd.valueZ = isnan(cmd.valueZ) ? pos.zmm : cmd.valueZ + pos.zmm;
    cmd.valueE = isnan(cmd.valueE) ? pos.emm : cmd.valueE + pos.emm; 
  } else {
    cmd.valueX = isnan(cmd.valueX) ? pos.xmm : cmd.valueX + pos_offset.xmm;
    cmd.valueY = isnan(cmd.valueY) ? pos.ymm : cmd.valueY + pos_offset.ymm;
    cmd.valueZ = isnan(cmd.valueZ) ? pos.zmm : cmd.valueZ + pos_offset.zmm;
    cmd.valueE = isnan(cmd.valueE) ? pos.emm : cmd.valueE + pos_offset.emm;
  }
}

void cmdDwell(Cmd(&cmd)){
  delay(int(cmd.valueS * 1000));
}

void printErr() {
  Logger::logERROR("COMMAND NOT RECOGNIZED");
}


file 10: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\command.h
#ifndef COMMAND_H_
#define COMMAND_H_

#include <Arduino.h>
#include "interpolation.h"

struct Cmd {
  char id;
  int num;
  float valueX;
  float valueY;
  float valueZ;
  float valueF;
  float valueE;
  float valueS; 
  float valueA;  // Sudut Servo A
  float valueB;  // Sudut Servo B
};

class Command {
  public:
    Command();
    bool handleGcode();
    bool processMessage(String msg);
    void value_segment(String msg_segment);
    Cmd getCmd() const;
    void cmdGetPosition(Point pos, Point pos_offset, float highRad, float lowRad, float rotRad);
    void cmdToRelative();
    void cmdToAbsolute();
    bool isRelativeCoord;
    Cmd new_command;

  private: 
    String message;
};

void cmdMove(Cmd(&cmd), Point pos, Point pos_offset, bool isRelativeCoord);
void cmdDwell(Cmd(&cmd));
void printErr();

#endif


file 11: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\config.h
#ifndef CONFIG_H_
#define CONFIG_H_

//PENGATURAN SERIAL
#define BAUD 115200

//PILIHAN BOARD MCU UNTUK ROBOT
#define BOARD_CHOICE MEGA2560
#define MEGA2560    0 //ARDUINO MEGA2560

//PANJANG LENGAN ROBOT
#define SHANK_LENGTH 140.0
#define LOW_SHANK_LENGTH 140.0
#define HIGH_SHANK_LENGTH 140.0

#define END_EFFECTOR_OFFSET 77.0// PANJANG DARI BEARING LENGAN ATAS KE TENGAH END EFFECTOR DALAM MM

//PENGATURAN INTERPOLASI AWAL
//  INITIAL_XYZ MEMBENTUK LENGAN BAWAH VERTIKAL & LENGAN ATAS HORIZONTAL PADA 90 DERAJAT
#define INITIAL_X 0.0 // KOORDINAT KARTESIUS X  
#define INITIAL_Y (HIGH_SHANK_LENGTH+END_EFFECTOR_OFFSET) // KOORDINAT KARTESIUS Y
#define INITIAL_Z 138.0 //LOW_SHANK_LENGTH // KOORDINAT KARTESIUS Z

#define INITIAL_E0 0.0 // POSISI ENDSTOP STEPPER REL 

//  KALIBRASI STEP HOME UNTUK MENCAPAI POSISI INITIAL_XYZ YANG DIINGINKAN
#define X_HOME_STEPS 850  //STEP DARI X_ENDSTOP KE INITIAL_XYZ UNTUK LENGAN ATAS (Z)
#define Y_HOME_STEPS 800  //STEP DARI Y_ENDSTOP KE INITIAL_XYZ UNTUK LENGAN BAWAH (Y)
#define Z_HOME_STEPS 3520 // STEP DARI Z_ENDSTOP KE INITIAL_XYZ UNTUK PUSAT ROTASI (X)
#define E0_HOME_STEPS 200 // STEP DARI E0_ENDSTOP KE INITIAL_E0

//PENGATURAN HOMING:
#define HOME_X_STEPPER true // "true" JIKA ENDSTOP TERPASANG
#define HOME_Y_STEPPER true // "true" JIKA ENDSTOP TERPASANG
#define HOME_Z_STEPPER true // "true" JIKA ENDSTOP TERPASANG
#define HOME_E0_STEPPER true // "true" JIKA ENDSTOP TERPASANG
#define HOME_ON_BOOT false // "true" JIKA PERLU HOMING SETELAH POWER ON
#define HOME_DWELL 700 // TAMBAH NILAI UNTUK MEMPERLAMBAT KECEPATAN HOMING

//PENGATURAN STEPPER:
#define MICROSTEPS 16 // KONFIGURASI MICROSTEPPING PADA RAMPS1.4
#define STEPS_PER_REV 200 // STEP PER PUTARAN UNTUK NEMA17
#define INVERSE_X_STEPPER true // UBAH JIKA STEPPER BERGERAK TERBALIK
#define INVERSE_Y_STEPPER false // UBAH JIKA STEPPER BERGERAK TERBALIK
#define INVERSE_Z_STEPPER false // UBAH JIKA STEPPER BERGERAK TERBALIK
#define INVERSE_E0_STEPPER true // UBAH JIKA STEPPER BERGERAK TERBALIK

//PENGATURAN REL: (microsteps 8)
#define RAIL false // Set nilai ke "true" jika menggunakan rel, set ke "false" jika robot tidak pakai rel.
#define STEPS_PER_MM_RAIL 80.0 // STEP PER MM UNTUK MOTOR REL
        //RUMUS: STEPS_PER_REV * MICROSTEPS / MOTOR_GEAR_TEETH / 2 
#define RAIL_LENGTH 355.0 // PANJANG MAKSIMAL REL DALAM MM

//PENGATURAN ENDSTOP:
#define X_MIN_INPUT 0 // NILAI OUTPUT SAAT SWITCH AKTIF - NO: 0, NC: 1
#define Y_MIN_INPUT 0 // NILAI OUTPUT SAAT SWITCH AKTIF - NO: 0, NC: 1
#define Z_MIN_INPUT 0 // NILAI OUTPUT SAAT SWITCH AKTIF - NO: 0, NC: 1
#define E0_MIN_INPUT 0 // NILAI OUTPUT SAAT SWITCH AKTIF - NO: 0, NC: 1

//PENGATURAN RASIO GERIGI
#define MOTOR_GEAR_TEETH 20.0 // 20.0 UNTUK VERSI BELT 20SFFACTORY   9.0 UNTUK VERSI GERIGI FTOBLER
#define MAIN_GEAR_TEETH 90.0 // 90.0 UNTUK VERSI BELT 20SFFACTORY   32.0 UNTUK VERSI GERIGI FTOBLER

//PENGATURAN PERALATAN
#define VACUM_DELAY_ON 300 // DURASI VACUM ON SEBELUM BERGERAK LAGI
#define VACUM_DELAY_OFF 500 // DURASI VACUM OFF SEBELUM BERGERAK LAGI
#define FAN_DELAY 1000 // DURASI FAN MENYALA DALAM DETIK

#define MAX_SERVO 160
#define MIN_SERVO 95

//PENGATURAN ANTRIAN PERINTAH
#define QUEUE_SIZE 15

//PENGATURAN BALASAN CETAK
#define PRINT_REPLY true // "true" UNTUK MENCETAK PESAN SETELAH SATU PERINTAH DIPROSES
#define PRINT_REPLY_MSG "ok" // PESAN YANG DIKIRIM UNTUK PEMROSESAN LANJUT DENGAN SOFTWARE LAIN

//PENGATURAN PROFIL KECEPATAN DEFAULT 
#define SPEED_PROFILE 2 // PILIHAN DIBAWAH
//0: KURVA KECEPATAN DATAR (KECEPATAN KONSTAN PER GERAKAN, COCOK UNTUK SOFTWARE KONTROL REAL-TIME)
//1: APROKSIMASI ARCTAN (AKSELERASI & DESELERASI KURVA LONCENG RINGAN)
//2: APROKSIMASI COSIN (AKSELERASI PENUH DARI 0 & DESELERASI KE 0, COCOK UNTUK GERAKAN PERINTAH PRESET)

//PENGATURAN LOG
#define LOG_LEVEL 2
//0: ERROR
//1: INFO
//2: DEBUG

//PARAMETER BATAS GERAK
#define Z_MIN -140.0 //TINGGI Z MINIMUM UJUNG TOOL MENYENTUH LANTAI
#define Z_MAX (LOW_SHANK_LENGTH+70.0) //PANJANG SHANK DITAMBAH ANGKA ACAK UNTUK Z_MAX
#define SHANKS_MIN_ANGLE_COS 0.791436948 
#define SHANKS_MAX_ANGLE_COS -0.774944489 
#define R_MIN (sqrt((sq(LOW_SHANK_LENGTH) + sq(HIGH_SHANK_LENGTH)) - (2*LOW_SHANK_LENGTH*HIGH_SHANK_LENGTH*SHANKS_MIN_ANGLE_COS) ))
#define R_MAX (sqrt((sq(LOW_SHANK_LENGTH) + sq(HIGH_SHANK_LENGTH)) - (2*LOW_SHANK_LENGTH*HIGH_SHANK_LENGTH*SHANKS_MAX_ANGLE_COS) ))

#endif


file 12: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\desktop.ini
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\76.0.3.0\GoogleDriveFS.exe,23


file 13: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\endstop.cpp
#include "endstop.h"
#include <Arduino.h>

Endstop::Endstop(int a_min_pin, int a_dir_pin, int a_step_pin, int a_en_pin, int a_switch_input, int a_step_offset, int a_home_dwell, bool does_swap_pin){
  min_pin = a_min_pin;
  dir_pin = a_dir_pin;
  step_pin = a_step_pin;
  en_pin = a_en_pin;
  switch_input = a_switch_input;
  home_dwell = a_home_dwell;
  step_offset = a_step_offset;
  swap_pin = does_swap_pin;
  if (swap_pin == false){
    pinMode(min_pin, INPUT_PULLUP);   
  }
}

void Endstop::home(bool dir) {
  if (swap_pin == true){
    pinMode(min_pin, INPUT_PULLUP);
    delayMicroseconds(5);
  }
  digitalWrite(en_pin, LOW);
  delayMicroseconds(5);
  if (dir==1){
    digitalWrite(dir_pin, HIGH);
  } else {
    digitalWrite(dir_pin, LOW);
  }
  delayMicroseconds(5);
  bState = !(digitalRead(min_pin) ^ switch_input);
  while (!bState) {
    digitalWrite(step_pin, HIGH);
    digitalWrite(step_pin, LOW);
    delayMicroseconds(home_dwell);
    bState = !(digitalRead(min_pin) ^ switch_input);
  }
  homeOffset(dir);
  if (swap_pin == true){
    pinMode(min_pin, OUTPUT);
    delayMicroseconds(5);
  }
}

void Endstop::homeOffset(bool dir){
  if (dir==1){
    digitalWrite(dir_pin, LOW);
  }
  else{
    digitalWrite(dir_pin, HIGH);
  }
  delayMicroseconds(5);
  for (int i = 1; i <= step_offset; i++) {
    digitalWrite(step_pin, HIGH);
    digitalWrite(step_pin, LOW);
    delayMicroseconds(home_dwell);
  }
}

void Endstop::oneStepToEndstop(bool dir){
  if (swap_pin == true){
    pinMode(min_pin, INPUT_PULLUP);
  }
  digitalWrite(en_pin, LOW);
  delayMicroseconds(5);
  if (dir==1){
    digitalWrite(dir_pin, HIGH);
  } else {
    digitalWrite(dir_pin, LOW);
  }
  delayMicroseconds(5);
  bState = !(digitalRead(min_pin) ^ switch_input);

  if (!bState) {
    digitalWrite(step_pin, HIGH);
    digitalWrite(step_pin, LOW);
    delayMicroseconds(home_dwell);
  }
  bState = !(digitalRead(min_pin) ^ switch_input);
}

bool Endstop::state(){
  if (swap_pin == true){
    pinMode(min_pin, INPUT_PULLUP);
    delayMicroseconds(5);
  }
  bState = !(digitalRead(min_pin) ^ switch_input);
  if (swap_pin == true){
    pinMode(min_pin, OUTPUT);
    delayMicroseconds(5);
  }
  return bState;
}

file 14: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\endstop.h
#ifndef ENDSTOP_H_
#define ENDSTOP_H_

class Endstop {
  public:
    Endstop(int a_min_pin, int a_dir_pin, int a_step_pin, int a_en_pin, int a_switch_input, int a_step_offset, int a_home_dwell, bool does_swap_pin);
    void home(bool dir);
    void homeOffset(bool dir);
    void oneStepToEndstop(bool dir);
    bool state();
    bool bState;

  private:
    int min_pin;
    int dir_pin;
    int step_pin;
    int en_pin;
    int switch_input;
    int home_dwell;
    int step_offset;
    bool swap_pin;    
};

#endif


file 15: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\equipment.cpp
#include "equipment.h"
#include <Arduino.h>

Equipment::Equipment(int equipment_pin){
  pin = equipment_pin;
  pinMode(pin, OUTPUT);
}

void Equipment::cmdOn(){
  digitalWrite(pin, HIGH);  
}

void Equipment::cmdOff(){
  digitalWrite(pin, LOW);  
}


file 16: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\equipment.h
#ifndef EQUIPMENT_H_
#define EQUIPMENT_H_

class Equipment {
public:
  Equipment(int equipment_pin);
  void cmdOn();
  void cmdOff();
private:
  int pin;
};

#endif


file 17: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\fanControl.cpp
#include "fanControl.h"
#include <Arduino.h>


FanControl::FanControl(int aPin, int aFanDelay) {
  fan_delay = aFanDelay * 1000;
  nextShutdown = 0;
  pin = aPin;
  pinMode(pin , OUTPUT);
  digitalWrite(pin , LOW);
  state = false;
}

void FanControl::enable(bool value) {
  if (value) {
    state = true;
    digitalWrite(pin, HIGH);
  } else {
    disable();
  }
}

void FanControl::disable() {
  state = false;
  nextShutdown = millis() + fan_delay;
  update();
}

void FanControl::update() {
  if (!state) {
     if (millis() >= nextShutdown) {
       digitalWrite(pin, LOW);
     }
  }
}


file 18: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\fanControl.h
#ifndef FANCONTROL_H_
#define FANCONTROL_H_

class FanControl {
public:
  FanControl(int aPin, int aFanDelay);
  void enable(bool value = true);
  void disable();
  void update();
private:
  bool state;
  int pin;
  long fan_delay;
  long nextShutdown;
};

#endif


file 19: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\Info update.txt
26/03/2025
1. Bisa request status sensor (M105)
    kirim "M105" ke serial untuk melihat status sensor

file 20: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\interpolation.cpp
#include "interpolation.h"
#include "config.h"
#include "queue.h"
#include "logger.h"

Interpolation::Interpolation(){
  speed_profile = SPEED_PROFILE;
  pos_offset.xmm = 0.0;
  pos_offset.ymm = 0.0;
  pos_offset.zmm = 0.0;
  pos_offset.emm = 0.0;
}

void Interpolation::setSpeedProfile(int new_speed_profile){
  speed_profile = new_speed_profile;
}

//G92 POSITION OFFSET FUNCTIONS
void Interpolation::setPosOffset(float new_x, float new_y, float new_z, float new_e) {
  pos_offset.xmm = xPosmm - new_x;
  pos_offset.ymm = yPosmm - new_y;
  pos_offset.zmm = zPosmm - new_z;
  pos_offset.emm = ePosmm - new_e;
  Logger::logINFO("POSITION OFFSET: [X" + String(pos_offset.xmm) + " Y:" + String(pos_offset.ymm) + " Z:" + String(pos_offset.zmm) + " E:" + String(pos_offset.emm) + "]");
  Logger::logINFO("CURRENT POSITION: [X:"+String(new_x)+" Y:"+String(new_y)+" Z:"+String(new_z)+" E:"+String(new_e)+"]");
}

void Interpolation::resetPosOffset(){
  pos_offset.xmm = 0.0;
  pos_offset.ymm = 0.0;
  pos_offset.zmm = 0.0;
  pos_offset.emm = 0.0;
}

Point Interpolation::getPosOffset() const {
  return pos_offset;
}


void Interpolation::setCurrentPos(float px, float py, float pz, float pe) {
  Point p;
  p.xmm = px;
  p.ymm = py;
  p.zmm = pz;
  p.emm = pe;
  setCurrentPos(p);
}

void Interpolation::setInterpolation(float px, float py, float pz, float pe, float v) {
  Point p;
  p.xmm = px;
  p.ymm = py;
  p.zmm = pz;
  p.emm = pe;
  setInterpolation(p, v);
}

void Interpolation::setInterpolation(float p1x, float p1y, float p1z, float p1e, float p2x, float p2y, float p2z, float p2e, float v) {
  Point p1;
  Point p2;
  p1.xmm = p1x;
  p1.ymm = p1y;
  p1.zmm = p1z;
  p1.emm = p1e;
  p2.xmm = p2x;
  p2.ymm = p2y;
  p2.zmm = p2z;
  p2.emm = p2e;
  setInterpolation(p1, p2, v);
}

void Interpolation::setInterpolation(Point p1, float v) {
  Point p0;
  p0.xmm = xStartmm + xDelta;
  p0.ymm = yStartmm + yDelta;
  p0.zmm = zStartmm + zDelta;
  p0.emm = eStartmm + eDelta;
  setInterpolation(p0, p1, v);
}

void Interpolation::setInterpolation(Point p0, Point p1, float av) {
  v = av; //mm/s
  
  float a = (p1.xmm - p0.xmm);
  float b = (p1.ymm - p0.ymm);
  float c = (p1.zmm - p0.zmm);
  float e = abs(p1.emm - p0.emm);
  float dist = sqrt(a*a + b*b + c*c);

  if (dist < e) {
    dist = e; 
  }

  if (v < 5) { //includes 0 = default value
    v = sqrt(dist) * 10; //set a good value for v
  }
  if (v < 5) {
     v = 5; 
  }
  
  tmul = v / dist;
  
  xStartmm = p0.xmm;
  yStartmm = p0.ymm;
  zStartmm = p0.zmm;
  eStartmm = p0.emm;
  
  xDelta = (p1.xmm - p0.xmm);
  yDelta = (p1.ymm - p0.ymm);
  zDelta = (p1.zmm - p0.zmm);
  eDelta = (p1.emm - p0.emm);
   
  state = 0;
  
  startTime = micros();
}

void Interpolation::setCurrentPos(Point p) {
  xStartmm = p.xmm;
  yStartmm = p.ymm;
  zStartmm = p.zmm;
  eStartmm = p.emm;
  xDelta = 0;
  yDelta = 0;
  zDelta = 0;
  eDelta = 0;
}

void Interpolation::updateActualPosition() {
  if (state != 0) {
    return;
  }    
  long microsek = micros();
  float t = (microsek - startTime) / 1000000.0;
  float progress;
  switch (speed_profile){
    // FLAT SPEED CURVE
    case 0:
      progress = t * tmul;
      if (progress >= 1.0){
        progress = 1.0;
        state = 1;
      }
      break;
    // ARCTAN APPROX
    case 1:
      progress = atan((PI * t * tmul) - (PI * 0.5)) * 0.5 + 0.5;
      if (progress >= 1.0) {
        progress = 1.0; 
        state = 1;
      }
      break;
    // COSIN APPROX
    case 2:
      progress = -cos(t * tmul * PI) * 0.5 + 0.5;
      if ((t * tmul) >= 1.0) {
        progress = 1.0; 
        state = 1;
      }
      break;
  }
  pos_tracker[X_AXIS] = xStartmm + progress * xDelta;
  pos_tracker[Y_AXIS] = yStartmm + progress * yDelta;
  pos_tracker[Z_AXIS] = zStartmm + progress * zDelta;
  pos_tracker[E_AXIS] = eStartmm + progress * eDelta;

  if(isAllowedPosition(pos_tracker)){
    xPosmm = pos_tracker[X_AXIS];
    yPosmm = pos_tracker[Y_AXIS];
    zPosmm = pos_tracker[Z_AXIS];
    ePosmm = pos_tracker[E_AXIS];
  } else {
    pos_tracker[X_AXIS] = xPosmm;
    pos_tracker[Y_AXIS] = yPosmm;
    pos_tracker[Z_AXIS] = zPosmm;
    pos_tracker[E_AXIS] = ePosmm;
    state = 1;
    progress = 1.0;
    xStartmm = xPosmm;
    yStartmm = yPosmm;
    zStartmm = zPosmm;
    eStartmm = ePosmm;
    xDelta = 0;
    yDelta = 0;
    zDelta = 0;
    eDelta = 0;
  }
  //FOR DECIPHERING SPEED CURVE
  //Serial.print("xPosmm:");
  //Serial.print(xPosmm);
  //Serial.print(" yPosmm:");
  //Serial.print(yPosmm);
  //Serial.print(" zPosmm:");
  //Serial.println(zPosmm);
}

bool Interpolation::isFinished() const {
  return state != 0; 
}

float Interpolation::getXPosmm() const {
  return xPosmm;
}

float Interpolation::getYPosmm() const {
  return yPosmm;
}

float Interpolation::getZPosmm() const {
  return zPosmm;
}

float Interpolation::getEPosmm() const {
  return ePosmm;
}

Point Interpolation::getPosmm() const {
  Point p;
  p.xmm = xPosmm;
  p.ymm = yPosmm;
  p.zmm = zPosmm;
  p.emm = ePosmm;
  return p;
}

bool Interpolation::isAllowedPosition(float pos_tracker[4]) {
  float rrot_ee = hypot(pos_tracker[X_AXIS], pos_tracker[Y_AXIS]);
  float rrot = rrot_ee - END_EFFECTOR_OFFSET; 
  float rrot_x = rrot * (pos_tracker[Y_AXIS] / rrot_ee);
  float rrot_y = rrot * (pos_tracker[X_AXIS] / rrot_ee);
  float squaredPositionModule = sq(rrot_x) + sq(rrot_y) + sq(pos_tracker[Z_AXIS]);  

      bool retVal = (
          squaredPositionModule <= sq(R_MAX) 
          && squaredPositionModule >= sq(R_MIN) 
          && pos_tracker[Z_AXIS] >= Z_MIN  
          && pos_tracker[Z_AXIS] <= Z_MAX 
          #if RAIL
          && pos_tracker[E_AXIS] <= RAIL_LENGTH
          && pos_tracker[E_AXIS] >= 0
          #endif
      );
  if(!retVal) {
    Logger::logERROR("LIMIT REACHED: [X:" + String(pos_tracker[X_AXIS]) + " Y:" + String(pos_tracker[Y_AXIS]) + " Z:" + String(pos_tracker[Z_AXIS]) + " E:" + String(pos_tracker[E_AXIS]) + "]");
  }
  return retVal;
}


file 21: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\interpolation.h
#ifndef INTERPOLATION_H_
#define INTERPOLATION_H_
#include <Arduino.h>

#define X_AXIS 0
#define Y_AXIS 1
#define Z_AXIS 2
#define E_AXIS 3

struct Point {
  float xmm;
  float ymm;
  float zmm;
  float emm;
};
class Interpolation {
public:
  //void resetInterpolation(float px, float py, float pz);
  //void resetInterpolation(float p1x, float p1y, float p1z, float p2x, float p2y, float p2z);
  //void resetInterpolation(Point p0, Point p1);
  Interpolation();
  void setCurrentPos(float px, float py, float pz, float pe);
  void setInterpolation(float px, float py, float pz, float pe, float v = 0);
  void setInterpolation(float p1x, float p1y, float p1z, float p1e, float p2x, float p2y, float p2z, float p2e, float av = 0);
  
  void setCurrentPos(Point p);
  void setInterpolation(Point p1, float v = 0);
  void setInterpolation(Point p0, Point p1, float v = 0);
  
  void updateActualPosition();
  bool isFinished() const;
  
  float getXPosmm() const;
  float getYPosmm() const;
  float getZPosmm() const;
  float getEPosmm() const;
  Point getPosmm() const;
  bool isAllowedPosition(float pos_tracker[4]);
  void setPosOffset(float new_x, float new_y, float new_z, float new_e);
  void resetPosOffset();
  Point getPosOffset() const;
  int speed_profile;
  void setSpeedProfile(int new_speed_profile);
  
private:
  Point pos_offset;
  float pos_tracker[4];
  byte state;
  
  long startTime;  
  
  float xStartmm;
  float yStartmm;
  float zStartmm;
  float eStartmm;
  float xDelta;
  float yDelta;
  float zDelta;
  float eDelta;
  float xPosmm;
  float yPosmm;
  float zPosmm;
  float ePosmm;
  float v;
  float tmul;
};

#endif


file 22: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\logger.cpp
#include "config.h"
#include "logger.h"

void Logger::log(String message, int level) {
  if(LOG_LEVEL >= level) {
    String logMsg;
    switch(level) {
      case LOG_ERROR:
        logMsg = "ERROR: ";
      break;
      case LOG_INFO:
        //logMsg = "INFO: ";
        logMsg;
      break;
      case LOG_DEBUG:
        logMsg = "DEBUG: ";
      break;
    }
    logMsg = logMsg + message;
    Serial.println(logMsg);
  }
}

void Logger::logERROR(String message) {
  log(message, LOG_ERROR);
}
void Logger::logINFO(String message) {
  log(message, LOG_INFO);
}
void Logger::logDEBUG(String message) {
  log(message, LOG_DEBUG);
}

file 23: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\logger.h
#ifndef LOGGER_H_
#define LOGGER_H_

#include <Arduino.h>

#define LOG_ERROR 0
#define LOG_INFO 1
#define LOG_DEBUG 2

class Logger {
  public:
    static void log(String message, int level);
    static void logINFO(String message);
    static void logERROR(String message);
    static void logDEBUG(String message);
};
#endif


file 24: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\queue.h
#ifndef QUEUE_H_
#define QUEUE_H_

template <typename Element> class Queue {
public:
  Queue(int alen);
  ~Queue();
  bool push(Element elem);
  Element pop();
  bool isFull() const;
  bool isEmpty() const;
  int getFreeSpace() const;
  int getMaxLength() const;
  inline int getUsedSpace() const;
private:
  Queue(Queue<Element>& q);  //copy const.
  Element* data;
  int len;
  int start;
  int count;
};

template <typename Element>
Queue<Element>::Queue(int alen) {
  data = new Element[alen];
  len = alen;
  start = 0;
  count = 0;
}

template <typename Element>
Queue<Element>::~Queue() {
  delete data;
}

template <typename Element>
Queue<Element>::Queue(Queue<Element>& q) {
  //nothing ever is allowed to do something here
}

template <typename Element>
bool Queue<Element>::push(Element elem) {
  data[(start + count++) % len] = elem;
}

template <typename Element>
Element Queue<Element>::pop() {
  count--;
  int s = start;
  start = (start + 1) % len;
  return data[(s) % len];
}

template <typename Element>
bool Queue<Element>::isFull() const {
  return count >= len;
}

template <typename Element>
bool Queue<Element>::isEmpty() const {
  return count <= 0;
}

template <typename Element>
int Queue<Element>::getFreeSpace() const {
  return len - count;
}

template <typename Element>
int Queue<Element>::getMaxLength() const {
  return len;
}

template <typename Element>
int Queue<Element>::getUsedSpace() const {
  return count;
}

#endif


file 25: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\RampsStepper.cpp
#include <Arduino.h>
#include "RampsStepper.h"

RampsStepper::RampsStepper(int aStepPin, int aDirPin, int aEnablePin, bool aInverse, float main_gear_teeth, float motor_gear_teeth, int microsteps, int steps_per_rev) {
  setReductionRatio(main_gear_teeth / motor_gear_teeth, microsteps * steps_per_rev);
  stepPin = aStepPin;
  dirPin = aDirPin;
  enablePin = aEnablePin;
  inverse = aInverse;
  stepperStepPosition = 0;
  stepperStepTargetPosition;
  pinMode(stepPin, OUTPUT);
  pinMode(dirPin, OUTPUT);
  pinMode(enablePin, OUTPUT);
  enable(false);
}

void RampsStepper::enable(bool value) {
  digitalWrite(enablePin, !value);
}

bool RampsStepper::isOnPosition() const {
  return stepperStepPosition == stepperStepTargetPosition;
}

int RampsStepper::getPosition() const {
  return stepperStepPosition;
}

void RampsStepper::setPosition(int value) {
  stepperStepPosition = value;
  stepperStepTargetPosition = value;
}

void RampsStepper::stepToPosition(int value) {
  stepperStepTargetPosition = value;
}

void RampsStepper::stepToPositionMM(float mm, float steps_per_mm) {
  stepperStepTargetPosition = mm * steps_per_mm;
}

void RampsStepper::stepRelative(int value) {
  value += stepperStepPosition;
  stepToPosition(value);
}

float RampsStepper::getPositionRad() const {
  return stepperStepPosition / radToStepFactor;
}

void RampsStepper::setPositionRad(float rad) {
  setPosition(rad * radToStepFactor);
}

void RampsStepper::stepToPositionRad(float rad) {
  stepperStepTargetPosition = rad * radToStepFactor;
}

void RampsStepper::stepRelativeRad(float rad) {
  stepRelative(rad * radToStepFactor);
}

void RampsStepper::update() {   
  while (stepperStepTargetPosition < stepperStepPosition) {  
    digitalWrite(dirPin, !inverse);
    digitalWrite(stepPin, HIGH);
    digitalWrite(stepPin, LOW);
    stepperStepPosition--;
  }
  
  while (stepperStepTargetPosition > stepperStepPosition) {    
    digitalWrite(dirPin, inverse);
    digitalWrite(stepPin, HIGH);
    digitalWrite(stepPin, LOW);
    stepperStepPosition++;
  }
}

void RampsStepper::setReductionRatio(float gearRatio, int stepsPerRev) {
  radToStepFactor = gearRatio * stepsPerRev / 2 / PI;
};


file 26: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\RampsStepper.h
#ifndef RAMPSSTEPPER_H_
#define RAMPSSTEPPER_H_

class RampsStepper {
public:
  RampsStepper(int aStepPin, int aDirPin, int aEnablePin, bool aInverse, float main_gear_teeth, float motor_gear_teeth, int microsteps, int steps_per_rev);
  void enable(bool value = true);
    
  bool isOnPosition() const;
  int getPosition() const;
  void setPosition(int value);
  void stepToPosition(int value);
  void stepToPositionMM(float mm, float steps_per_mm);
  void stepRelative(int value);
  float getPositionRad() const;
  void setPositionRad(float rad);
  void stepToPositionRad(float rad);
  void stepRelativeRad(float rad);
  
  void update();
  
  void setReductionRatio(float gearRatio, int stepsPerRev);
private:
  int stepperStepTargetPosition;
  int stepperStepPosition;
  int stepPin;
  int dirPin;
  int enablePin;  
  bool inverse;
  float radToStepFactor;
};

#endif


file 27: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\robotGeometry.cpp
#include "robotGeometry.h"

#include <math.h>
#include <Arduino.h>

RobotGeometry::RobotGeometry(float a_ee_offset, float a_low_shank_length, float a_high_shank_length) {
  ee_offset = a_ee_offset;
  low_shank_length = a_low_shank_length;
  high_shank_length = a_high_shank_length;
}

void RobotGeometry::set(float axmm, float aymm, float azmm) {
  xmm = axmm;
  ymm = aymm;
  zmm = azmm; 
  calculateGrad();
}

float RobotGeometry::getXmm() const {
  return xmm;
}

float RobotGeometry::getYmm() const {
  return ymm;
}

float RobotGeometry::getZmm() const {
  return zmm;
}

float RobotGeometry::getRotRad() const {
  return rot;
}

float RobotGeometry::getLowRad() const {
  return low;
}

float RobotGeometry::getHighRad() const {
  return high;
}

float RobotGeometry::getHypot() const {
  return rrot_ee;
}

void RobotGeometry::calculateGrad() {
   rrot_ee =  hypot(xmm, ymm);    
   float rrot = rrot_ee - ee_offset; //radius from Top View
   float rside = hypot(rrot, zmm);  //radius from Side View. Use rrot instead of ymm..for everything
   float rside_2 = sq(rside);
   float low_2 = sq(low_shank_length);
   float high_2 = sq(high_shank_length);
   
   rot = asin(xmm / rrot_ee);
   high = PI - acos((low_2 + high_2 - rside_2) / (2 * low_shank_length * high_shank_length));

   //Angle of Lower Stepper Motor  (asin()=Angle To Gripper)
   if (zmm > 0) {
     low =  acos(zmm / rside) - acos((low_2 - high_2 + rside_2) / (2 * low_shank_length * rside));
   } else {
     low = PI - asin(rrot / rside) - acos((low_2 - high_2 + rside_2) / (2 * low_shank_length * rside));
   }
   high = high + low;
}


file 28: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\robotGeometry.h
#ifndef ROBOTGEOMETRY_H_
#define ROBOTGEOMETRY_H_

class RobotGeometry {
public:
  RobotGeometry(float a_ee_offset, float a_low_shank_length, float a_high_length);
  void set(float axmm, float aymm, float azmm);
  float getXmm() const;
  float getYmm() const;
  float getZmm() const;
  float getRotRad() const;
  float getLowRad() const;
  float getHighRad() const;
  float getHypot() const;
private:
  void calculateGrad();
  float ee_offset;
  float low_shank_length;
  float high_shank_length;
  float xmm;
  float ymm;
  float zmm;
  float rot;
  float low;
  float high;
  float rrot_ee;
};

#endif


file 29: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\robotRNV3_v2_02.ino
#include <Arduino.h>
//GENERAL CONFIG SETTINGS
#include "config.h"

#include "robotGeometry.h"
#include "interpolation.h"
#include "RampsStepper.h"
#include "queue.h"
#include "command.h"
#include "equipment.h"
#include "endstop.h"
#include "logger.h"
#include "fanControl.h"
#include <Servo.h>
#include "pinout/pinout.h"

int targetServoA = -1;
int targetServoB = -1;
bool waitingForServo = false;
unsigned long servoMoveStartTime = 0;
int servoMoveDuration = 0;  // Waktu estimasi servo sampai target (ms)


//STEPPER OBJECTS
RampsStepper stepperHigher(X_STEP_PIN, X_DIR_PIN, X_ENABLE_PIN, INVERSE_X_STEPPER, MAIN_GEAR_TEETH, MOTOR_GEAR_TEETH, MICROSTEPS, STEPS_PER_REV);
RampsStepper stepperLower(Y_STEP_PIN, Y_DIR_PIN, Y_ENABLE_PIN, INVERSE_Y_STEPPER, MAIN_GEAR_TEETH, MOTOR_GEAR_TEETH, MICROSTEPS, STEPS_PER_REV);
RampsStepper stepperRotate(Z_STEP_PIN, Z_DIR_PIN, Z_ENABLE_PIN, INVERSE_Z_STEPPER, MAIN_GEAR_TEETH, MOTOR_GEAR_TEETH, MICROSTEPS, STEPS_PER_REV);

//RAIL OBJECTS
#if RAIL
  RampsStepper stepperRail(E0_STEP_PIN, E0_DIR_PIN, E0_ENABLE_PIN, INVERSE_E0_STEPPER, MAIN_GEAR_TEETH, MOTOR_GEAR_TEETH, MICROSTEPS, STEPS_PER_REV);
  Endstop endstopE0(E0_MIN_PIN, E0_DIR_PIN, E0_STEP_PIN, E0_ENABLE_PIN, E0_MIN_INPUT, E0_HOME_STEPS, HOME_DWELL, false);
#endif

//ENDSTOP OBJECTS
Endstop endstopX(X_MIN_PIN, X_DIR_PIN, X_STEP_PIN, X_ENABLE_PIN, X_MIN_INPUT, X_HOME_STEPS, HOME_DWELL, false);
Endstop endstopY(Y_MIN_PIN, Y_DIR_PIN, Y_STEP_PIN, Y_ENABLE_PIN, Y_MIN_INPUT, Y_HOME_STEPS, HOME_DWELL, false);
Endstop endstopZ(Z_MIN_PIN, Z_DIR_PIN, Z_STEP_PIN, Z_ENABLE_PIN, Z_MIN_INPUT, Z_HOME_STEPS, HOME_DWELL, false);


Equipment lg1(LG1_PIN);
Equipment lg2(LG2_PIN);
Equipment lg3(LG3_PIN);
Equipment led(LED_PIN);
FanControl fan(FAN_PIN, FAN_DELAY);

//EXECUTION & COMMAND OBJECTS
RobotGeometry geometry(END_EFFECTOR_OFFSET, LOW_SHANK_LENGTH, HIGH_SHANK_LENGTH);
Interpolation interpolator;
Queue<Cmd> queue(QUEUE_SIZE);
Command command;

//---------------------------------IO-------------------------------------------
int IO1Before = LOW;
int IO2Before = LOW;
int IO3Before = LOW;
//------------------------------------------------------------------------------

Servo servoA;
Servo servoB;

static bool waitingForMotion = false;

void setup() {
  Serial.begin(BAUD);
  stepperHigher.setPositionRad(PI / 2.0); // 90°
  stepperLower.setPositionRad(0);         // 0°
  stepperRotate.setPositionRad(0);        // 0°
  #if RAIL
  stepperRail.setPosition(0);
  #endif

  Logger::logINFO("SETUP GRIPPER SERVO : MIN " + String(MIN_SERVO) + " MAX " + String(MAX_SERVO));
  delay(50);

  if (HOME_ON_BOOT) {
    homeSequence(); 
    Logger::logINFO("ROBOT ONLINE");
  } else {
    setStepperEnable(false);
    if (RAIL) {
      delay(100);
      Logger::logINFO("RAIL ON");
    } else {
      delay(100);  
      Logger::logINFO("RAIL OFF");
    }
    if (HOME_X_STEPPER && HOME_Y_STEPPER && !HOME_Z_STEPPER){
      Logger::logINFO("PUTAR ROBOT KE DEPAN TENGAH & KIRIM G28 UNTUK KALIBRASI");
    }
    if (HOME_X_STEPPER && HOME_Y_STEPPER && HOME_Z_STEPPER){
      delay(100);
      Logger::logINFO("READY CALIBRATION");
    }
    if (!HOME_X_STEPPER && !HOME_Y_STEPPER){
      Logger::logINFO("HOME ROBOT MANUALLY & SEND G28 TO CALIBRATE");
    }
  }
  interpolator.setInterpolation(INITIAL_X, INITIAL_Y, INITIAL_Z, INITIAL_E0, INITIAL_X, INITIAL_Y, INITIAL_Z, INITIAL_E0);
  
//-------------------------------------IO------------------------------------------------
  pinMode(IO1_PIN, INPUT);
  pinMode(IO2_PIN, INPUT);
  pinMode(IO3_PIN, INPUT);
//-----------------------------------------------------------------------------------------
  lg1.cmdOff();
  lg2.cmdOff();
  lg3.cmdOff();
  servoA.attach(SERVO_PIN_A);  // Pin Servo A
  servoB.attach(SERVO_PIN);  // Pin Servo B
  servoA.write(90);  // Set awal ke 50°
  servoB.write(MAX_SERVO);  // Set awal ke 50°
}

void loop() {

  interpolator.updateActualPosition();
  geometry.set(interpolator.getXPosmm(), interpolator.getYPosmm(), interpolator.getZPosmm());
  stepperRotate.stepToPositionRad(geometry.getRotRad());
  stepperLower.stepToPositionRad(geometry.getLowRad());
  stepperHigher.stepToPositionRad(geometry.getHighRad());
  #if RAIL
    stepperRail.stepToPositionMM(interpolator.getEPosmm(), STEPS_PER_MM_RAIL);
  #endif
  stepperRotate.update();
  stepperLower.update();
  stepperHigher.update();
  #if RAIL
    stepperRail.update();
  #endif
  fan.update();

  // Jika antrean perintah tidak penuh dan tidak sedang menunggu gerakan, ambil perintah baru
  if (!queue.isFull() && !waitingForMotion && !waitingForServo) {
      if (command.handleGcode()) {
          queue.push(command.getCmd());
      }
  }

  // Jika ada perintah dalam antrean dan gerakan sebelumnya selesai, eksekusi perintah
  if (!queue.isEmpty() && interpolator.isFinished() && !waitingForMotion && !waitingForServo) {
      Cmd currentCmd = queue.pop();
      executeCommand(currentCmd);
      
      // Hanya set waitingForMotion jika bukan perintah M208
      if (!(currentCmd.id == 'M' && currentCmd.num == 208)) {
          waitingForMotion = true;
      }
  }

  // Kirim "ok" setelah motor stepper selesai bergerak
if (waitingForMotion && interpolator.isFinished()) {
    if (!waitingForServo) {  // Pastikan servo tidak bergerak sebelum mengirim "ok"
        if (PRINT_REPLY) {
          Serial.println(PRINT_REPLY_MSG);
        }
        waitingForMotion = false;  // Reset flag setelah stepper selesai
    }
}

// Kirim "ok" setelah servo selesai bergerak
if (waitingForServo && (millis() - servoMoveStartTime >= servoMoveDuration)) {
    waitingForServo = false;  // Reset flag setelah servo selesai
    targetServoA = -1;
    targetServoB = -1;
}

//-----------------------------------------------------------------------------

  if (millis() % 500 < 250) {
    led.cmdOn();
  }
  else {
    led.cmdOff();
  }

 //============== SENSOR =======================================================
  if (digitalRead(IO1_PIN) == HIGH && IO1Before == LOW) {
      Logger::logINFO("S1 ON");
      IO1Before = HIGH;
  } else if (digitalRead(IO1_PIN) == LOW && IO1Before == HIGH) {
      Logger::logINFO("S1 OFF");
      IO1Before = LOW;
  }

  if (digitalRead(IO2_PIN) == HIGH && IO2Before == LOW) {
      Logger::logINFO("S2 ON");
      IO2Before = HIGH;
  } else if (digitalRead(IO2_PIN) == LOW && IO2Before == HIGH) {
      Logger::logINFO("S2 OFF");
      IO2Before = LOW;
  }

  if (digitalRead(IO3_PIN) == HIGH && IO3Before == LOW) {
      Logger::logINFO("S3 ON");
      IO3Before = HIGH;
  } else if (digitalRead(IO3_PIN) == LOW && IO3Before == HIGH) {
      Logger::logINFO("S3 OFF");
      IO3Before = LOW;
  }
}


void executeCommand(Cmd cmd) {

  if (cmd.id == -1) {
    printErr();
    return;
  }

  if (cmd.id == 'G') {
    switch (cmd.num) {
    case 0:
    case 1:
            fan.enable(true);
            Point posoffset;
            posoffset = interpolator.getPosOffset();      
            cmdMove(cmd, interpolator.getPosmm(), posoffset, command.isRelativeCoord);
            interpolator.setInterpolation(cmd.valueX, cmd.valueY, cmd.valueZ, cmd.valueE, cmd.valueF);
            Logger::logINFO("LINEAR MOVE: [X:" + String(cmd.valueX-posoffset.xmm) + " Y:" + String(cmd.valueY-posoffset.ymm) + " Z:" + String(cmd.valueZ-posoffset.zmm) + " E:" + String(cmd.valueE-posoffset.emm)+"]");
    case 4: cmdDwell(cmd); break;
    case 28:  homeSequence(); break;  // Hapus pilihan board lain, hanya gunakan sequence untuk Mega
    case 90:  command.cmdToAbsolute(); break; // ABSOLUTE COORDINATE MODE
    case 91:  command.cmdToRelative(); break; // RELATIVE COORDINATE MODE
    case 92:  interpolator.resetPosOffset(); cmdMove(cmd, interpolator.getPosmm(), interpolator.getPosOffset(), false);
              interpolator.setPosOffset(cmd.valueX, cmd.valueY, cmd.valueZ, cmd.valueE); break;
    case 100: {  // G100: Gerakan Servo
              String logMessage = "SERVO MOVE: [";
              bool firstValue = true;

              float waktuPerDerajat = 5;
              float waktuA = 0, waktuB = 0;

              // Cek dan proses cmd.valueA
              if (!isnan(cmd.valueA) && cmd.valueA >= 0 && cmd.valueA <= 180) {
                  float posisiSekarangA = servoA.read();  // Baca posisi saat ini
                  float deltaA = abs(cmd.valueA - posisiSekarangA); // Hitung selisih sudut
                  waktuA = deltaA * waktuPerDerajat; // Hitung estimasi waktu

                  servoA.write(cmd.valueA);
                  logMessage += "A:" + String(cmd.valueA, 2);
                  firstValue = false;
                  targetServoA = cmd.valueA;  
              } else {
                  Serial.println("Nilai cmd.valueA di luar rentang yang diizinkan!");
              }

              // Cek dan proses cmd.valueB
              if (!isnan(cmd.valueB) && cmd.valueB >= MIN_SERVO && cmd.valueB <= MAX_SERVO) {
                  float posisiSekarangB = servoB.read();  
                  float deltaB = abs(cmd.valueB - posisiSekarangB); 
                  waktuB = deltaB * waktuPerDerajat; 

                  servoB.write(cmd.valueB);
                  if (!firstValue) logMessage += " ";
                  logMessage += "B:" + String(cmd.valueB, 2);
                  targetServoB = cmd.valueB;  
              } else {
                  Serial.println("Nilai cmd.valueB di luar rentang yang diizinkan!");
              }

              logMessage += "]";
              Logger::logINFO(logMessage);

              // Aktifkan flag untuk menunggu servo selesai
              waitingForServo = true;
              servoMoveStartTime = millis();

              // Pilih waktu terlama dari kedua servo agar replay "ok" sesuai
              servoMoveDuration = max(waktuA, waktuB);  

              break;
            }

    default: printErr();
    }
  }
  else if (cmd.id == 'M') {
    switch (cmd.num) {
    case 1: lg1.cmdOn(); break;
    case 2: lg1.cmdOff(); break;
    case 6: lg3.cmdOn(); break;
    case 7: lg3.cmdOff(); break;
    case 17: setStepperEnable(true); break;
    case 18: setStepperEnable(false); break;
    case 105: {
      // Read and report all sensor states
      String sensorStatus = "SENSOR STATUS: [S1:";
      sensorStatus += String(digitalRead(IO1_PIN) == HIGH ? "ON" : "OFF");
      sensorStatus += " S2:";
      sensorStatus += String(digitalRead(IO2_PIN) == HIGH ? "ON" : "OFF");
      sensorStatus += " S3:";
      sensorStatus += String(digitalRead(IO3_PIN) == HIGH ? "ON" : "OFF");
      sensorStatus += "]";
      Logger::logINFO(sensorStatus);
      break;
    }
    case 106: fan.enable(true); break;
    case 107: fan.enable(false); break;
    case 114: command.cmdGetPosition(interpolator.getPosmm(), interpolator.getPosOffset(), stepperHigher.getPosition(), stepperLower.getPosition(), stepperRotate.getPosition()); break;// Return the current positions of all axis 
    case 119: {
      String endstopMsg = "ENDSTOP: [X:";
      endstopMsg += String(endstopX.state());
      endstopMsg += " Y:";
      endstopMsg += String(endstopY.state());
      endstopMsg += " Z:";
      endstopMsg += String(endstopZ.state());
      #if RAIL
        endstopMsg += " E:";
        endstopMsg += String(endstopE0.state());
      #endif
      endstopMsg += "]";
      Logger::logINFO(endstopMsg);
      break;}
    case 205:
      interpolator.setSpeedProfile(cmd.valueS); 
      Logger::logINFO("SPEED PROFILE: [" + String(interpolator.speed_profile) + "]");
      break;
    case 206: lg2.cmdOn(); break;
    case 207: lg2.cmdOff(); break;

    case 208: lg2.cmdOff(); break;

    case 209: {
                lg3.cmdOn(); 
                lg2.cmdOff();
                delay(VACUM_DELAY_ON);
                break;
    }  

    case 230: {
                lg3.cmdOff(); 
                lg2.cmdOn();
                Logger::logINFO("Tunggu..");
                delay(VACUM_DELAY_OFF);
                lg2.cmdOff();
                break;
    }
    
    default: printErr();
    }
  }
  else {
    printErr();
  }
}

void setStepperEnable(bool enable){
  stepperRotate.enable(enable);
  stepperLower.enable(enable);
  stepperHigher.enable(enable);
  #if RAIL
    stepperRail.enable(enable);
  #endif
  fan.enable(enable);
}

void homeSequence(){
  setStepperEnable(false);
  fan.enable(true);
  if (HOME_Y_STEPPER && HOME_X_STEPPER){
    endstopY.home(!INVERSE_Y_STEPPER);
    endstopX.home(!INVERSE_X_STEPPER);
  } else {
    setStepperEnable(true);
    endstopY.homeOffset(!INVERSE_Y_STEPPER);
    endstopX.homeOffset(!INVERSE_X_STEPPER);
  }
  if (HOME_Z_STEPPER){
    endstopZ.home(INVERSE_Z_STEPPER);
  }
  #if RAIL
    if (HOME_E0_STEPPER){
      endstopE0.home(!INVERSE_E0_STEPPER);
    }
  #endif
  interpolator.setInterpolation(INITIAL_X, INITIAL_Y, INITIAL_Z, INITIAL_E0, INITIAL_X, INITIAL_Y, INITIAL_Z, INITIAL_E0);
  Logger::logINFO("HOMING COMPLETE");
}



file 30: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\pinout\desktop.ini
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\76.0.3.0\GoogleDriveFS.exe,23


file 31: C:\coding\blackcobra-cpp\src\robotRNV3_v2_02\pinout\pinout.h
#ifndef PINOUT_H_
#define PINOUT_H_

/*
 * pinout of RAMPS 1.4
 *
 * source: http://reprap.org/wiki/RAMPS_1.4
 */

//RAMPS 1.4 PINS
#define X_STEP_PIN         54
#define X_DIR_PIN          55
#define X_ENABLE_PIN       38
#define X_MIN_PIN           3
#define X_MAX_PIN           2
 
#define Y_STEP_PIN         60
#define Y_DIR_PIN          61
#define Y_ENABLE_PIN       56
#define Y_MIN_PIN          14
#define Y_MAX_PIN          15

#define Z_STEP_PIN         46
#define Z_DIR_PIN          48
#define Z_ENABLE_PIN       62
#define Z_MIN_PIN          18
#define Z_MAX_PIN          19

#define E0_STEP_PIN        26
#define E0_DIR_PIN         28
#define E0_ENABLE_PIN      24
#define E0_MIN_PIN         20

#define E1_STEP_PIN        36
#define E1_DIR_PIN         34
#define E1_ENABLE_PIN      30
#define E1_MIN_PIN         41
#define E1_MAX_PIN         43

#define BYJ_PIN_0          40
#define BYJ_PIN_1          63
#define BYJ_PIN_2          59
#define BYJ_PIN_3          64

#define SERVO_PIN           4
#define SERVO_PIN_A         5

#define LG1_PIN            8
#define LG2_PIN            9
#define LG3_PIN            10

#define LED_PIN            13

#define SDPOWER            -1
#define SDSS               53

#define FAN_PIN            22

#define PS_ON_PIN          12
#define KILL_PIN           -1

#define IO1_PIN            16
#define IO2_PIN            17
#define IO3_PIN            57
#define IO4_PIN            25
#define IO5_PIN            27
#define IO6_PIN            29
#define IO7_PIN            31
#define IO8_PIN            33
#define IO9_PIN            35
#define IO10_PIN           37

//#define HEATER_0_PIN       10
//#define HEATER_1_PIN        8
#define TEMP_0_PIN         13   // ANALOG NUMBERING
#define TEMP_1_PIN         14   // ANALOG NUMBERING

//RAMPS AUX-2


#endif


