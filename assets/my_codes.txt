file 1: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\command.cpp
#include "command.h"
#include "logger.h"
#include <Arduino.h>

Command::Command() {
  //initialize Command to a zero-move value;
  new_command.valueX = NAN; 
  new_command.valueY = NAN;
  new_command.valueZ = NAN;
  new_command.valueF = 0;
  new_command.valueE = NAN;
  new_command.valueS = 0;
  message = "";
  isRelativeCoord = false;
}

bool Command::handleGcode() {
  if (Serial.available()) {
    char c = Serial.read();
    if (c == '\n') {
       return false; 
    }
    if (c == '\r') {
       bool success = processMessage(message);
       message = "";
       return success;  // Hanya kembalikan status, tidak kirim "ok" di sini
    } else {
       message += c; 
    }
  }
  return false;
}


bool Command::processMessage(String msg){

  // Tambahkan pengecekan untuk "VACUM ON" dan "VACUM OFF"
  if (msg.equalsIgnoreCase("VACUM ON")) {
    msg = "M209";
  } else if (msg.equalsIgnoreCase("VACUM OFF")) {
    msg = "M230";
  } else if (msg.equalsIgnoreCase("LG1 ON")) {
    msg = "M1";
  } else if (msg.equalsIgnoreCase("LG1 OFF")) {
    msg = "M2";
  } else if (msg.equalsIgnoreCase("LG2 ON")) {
    msg = "M206";
  } else if (msg.equalsIgnoreCase("LG2 OFF")) {
    msg = "M207";
  } else if (msg.equalsIgnoreCase("LG3 ON")) {
    msg = "M6";
  } else if (msg.equalsIgnoreCase("LG3 OFF")) {
    msg = "M7";
  }

  new_command.valueX = NAN; 
  new_command.valueY = NAN;
  new_command.valueZ = NAN;
  new_command.valueE = NAN;
  new_command.valueF = 0;
  new_command.valueS = 0;  
  msg.toUpperCase();
  msg.replace(" ", "");
  int active_index = 0;
  new_command.id = msg[active_index];
  if((new_command.id != 'G') && (new_command.id != 'M')){
    printErr();
    return false;
  }

  active_index++;
  int temp_index = active_index;
  while (temp_index<msg.length() && !isAlpha(msg[temp_index])){
    temp_index++;
  }
  new_command.num = msg.substring(active_index, temp_index).toInt();
  active_index = temp_index;
  temp_index++;
  while (temp_index<msg.length()){
    while (!isAlpha(msg[temp_index]) || msg[temp_index]=='.'){
      temp_index++;
      if (temp_index == msg.length()){
        break;
      }
    }
    value_segment(msg.substring(active_index, temp_index));
    active_index = temp_index;
    temp_index++;
  }
  return true;
}

void Command::value_segment(String msg_segment){
  float msg_value = msg_segment.substring(1).toFloat();
  switch (msg_segment[0]){
    case 'X': new_command.valueX = msg_value; break;
    case 'Y': new_command.valueY = msg_value; break;
    case 'Z': new_command.valueZ = msg_value; break;
    case 'E': new_command.valueE = msg_value; break;
    case 'F': new_command.valueF = msg_value; break;
    case 'S': new_command.valueS = msg_value; break;
    case 'A': new_command.valueA = msg_value; break; // Tambahkan ini
    case 'B': new_command.valueB = msg_value; break; // Tambahkan ini
  }
}


Cmd Command::getCmd() const {
  return new_command; 
}

void Command::cmdGetPosition(Point pos, Point pos_offset, float highRad, float lowRad, float rotRad){
  if(isRelativeCoord) {
    Logger::logINFO("RELATIVE MODE");
  } else {
    Logger::logINFO("ABSOLUTE MODE");
  }
  Logger::logINFO("CURRENT POSITION: [X:"+String(pos.xmm - pos_offset.xmm)+" Y:"+String(pos.ymm - pos_offset.ymm)+" Z:"+String(pos.zmm - pos_offset.zmm)+" E:"+String(pos.emm - pos_offset.emm)+"]");
  //Logger::logINFO("RADIANS: [HIGH:"+String(highRad)+" LOW:"+String(lowRad)+" ROT:"+String(rotRad));
}

void Command::cmdToRelative(){
  isRelativeCoord = true;
  Logger::logINFO("RELATIVE MODE ON");
}

void Command::cmdToAbsolute(){
  isRelativeCoord = false;
  Logger::logINFO("ABSOLUTE MODE ON");
}

void cmdMove(Cmd(&cmd), Point pos, Point pos_offset, bool isRelativeCoord){

  if(isRelativeCoord == true){
    cmd.valueX = isnan(cmd.valueX) ? pos.xmm : cmd.valueX + pos.xmm;
    cmd.valueY = isnan(cmd.valueY) ? pos.ymm : cmd.valueY + pos.ymm;
    cmd.valueZ = isnan(cmd.valueZ) ? pos.zmm : cmd.valueZ + pos.zmm;
    cmd.valueE = isnan(cmd.valueE) ? pos.emm : cmd.valueE + pos.emm; 
  } else {
    cmd.valueX = isnan(cmd.valueX) ? pos.xmm : cmd.valueX + pos_offset.xmm;
    cmd.valueY = isnan(cmd.valueY) ? pos.ymm : cmd.valueY + pos_offset.ymm;
    cmd.valueZ = isnan(cmd.valueZ) ? pos.zmm : cmd.valueZ + pos_offset.zmm;
    cmd.valueE = isnan(cmd.valueE) ? pos.emm : cmd.valueE + pos_offset.emm;
  }
}

void cmdDwell(Cmd(&cmd)){
  delay(int(cmd.valueS * 1000));
}

void printErr() {
  Logger::logERROR("COMMAND NOT RECOGNIZED");
}


file 2: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\command.h
#ifndef COMMAND_H_
#define COMMAND_H_

#include <Arduino.h>
#include "interpolation.h"

struct Cmd {
  char id;
  int num;
  float valueX;
  float valueY;
  float valueZ;
  float valueF;
  float valueE;
  float valueS; 
  float valueA;  // Sudut Servo A
  float valueB;  // Sudut Servo B
};

class Command {
  public:
    Command();
    bool handleGcode();
    bool processMessage(String msg);
    void value_segment(String msg_segment);
    Cmd getCmd() const;
    void cmdGetPosition(Point pos, Point pos_offset, float highRad, float lowRad, float rotRad);
    void cmdToRelative();
    void cmdToAbsolute();
    bool isRelativeCoord;
    Cmd new_command;

  private: 
    String message;
};

void cmdMove(Cmd(&cmd), Point pos, Point pos_offset, bool isRelativeCoord);
void cmdDwell(Cmd(&cmd));
void printErr();

#endif


file 3: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\config.h
#ifndef CONFIG_H_
#define CONFIG_H_

//PENGATURAN SERIAL
#define BAUD 115200

//PILIHAN BOARD MCU UNTUK ROBOT
#define BOARD_CHOICE MEGA2560
#define MEGA2560    0 //ARDUINO MEGA2560

//PANJANG LENGAN ROBOT
#define SHANK_LENGTH 140.0
#define LOW_SHANK_LENGTH 140.0
#define HIGH_SHANK_LENGTH 140.0

#define END_EFFECTOR_OFFSET 77.0// PANJANG DARI BEARING LENGAN ATAS KE TENGAH END EFFECTOR DALAM MM

//PENGATURAN INTERPOLASI AWAL
//  INITIAL_XYZ MEMBENTUK LENGAN BAWAH VERTIKAL & LENGAN ATAS HORIZONTAL PADA 90 DERAJAT
#define INITIAL_X 0.0 // KOORDINAT KARTESIUS X  
#define INITIAL_Y (HIGH_SHANK_LENGTH+END_EFFECTOR_OFFSET) // KOORDINAT KARTESIUS Y
#define INITIAL_Z 138.0 //LOW_SHANK_LENGTH // KOORDINAT KARTESIUS Z

#define INITIAL_E0 0.0 // POSISI ENDSTOP STEPPER REL 

//  KALIBRASI STEP HOME UNTUK MENCAPAI POSISI INITIAL_XYZ YANG DIINGINKAN
#define X_HOME_STEPS 850  //STEP DARI X_ENDSTOP KE INITIAL_XYZ UNTUK LENGAN ATAS (Z)
#define Y_HOME_STEPS 800  //STEP DARI Y_ENDSTOP KE INITIAL_XYZ UNTUK LENGAN BAWAH (Y)
#define Z_HOME_STEPS 3520 // STEP DARI Z_ENDSTOP KE INITIAL_XYZ UNTUK PUSAT ROTASI (X)
#define E0_HOME_STEPS 200 // STEP DARI E0_ENDSTOP KE INITIAL_E0

//PENGATURAN HOMING:
#define HOME_X_STEPPER true // "true" JIKA ENDSTOP TERPASANG
#define HOME_Y_STEPPER true // "true" JIKA ENDSTOP TERPASANG
#define HOME_Z_STEPPER true // "true" JIKA ENDSTOP TERPASANG
#define HOME_E0_STEPPER true // "true" JIKA ENDSTOP TERPASANG
#define HOME_ON_BOOT false // "true" JIKA PERLU HOMING SETELAH POWER ON
#define HOME_DWELL 700 // TAMBAH NILAI UNTUK MEMPERLAMBAT KECEPATAN HOMING

//PENGATURAN STEPPER:
#define MICROSTEPS 16 // KONFIGURASI MICROSTEPPING PADA RAMPS1.4
#define STEPS_PER_REV 200 // STEP PER PUTARAN UNTUK NEMA17
#define INVERSE_X_STEPPER true // UBAH JIKA STEPPER BERGERAK TERBALIK
#define INVERSE_Y_STEPPER false // UBAH JIKA STEPPER BERGERAK TERBALIK
#define INVERSE_Z_STEPPER false // UBAH JIKA STEPPER BERGERAK TERBALIK
#define INVERSE_E0_STEPPER true // UBAH JIKA STEPPER BERGERAK TERBALIK

//PENGATURAN REL: (microsteps 8)
#define RAIL false // Set nilai ke "true" jika menggunakan rel, set ke "false" jika robot tidak pakai rel.
#define STEPS_PER_MM_RAIL 80.0 // STEP PER MM UNTUK MOTOR REL
        //RUMUS: STEPS_PER_REV * MICROSTEPS / MOTOR_GEAR_TEETH / 2 
#define RAIL_LENGTH 355.0 // PANJANG MAKSIMAL REL DALAM MM

//PENGATURAN ENDSTOP:
#define X_MIN_INPUT 0 // NILAI OUTPUT SAAT SWITCH AKTIF - NO: 0, NC: 1
#define Y_MIN_INPUT 0 // NILAI OUTPUT SAAT SWITCH AKTIF - NO: 0, NC: 1
#define Z_MIN_INPUT 0 // NILAI OUTPUT SAAT SWITCH AKTIF - NO: 0, NC: 1
#define E0_MIN_INPUT 0 // NILAI OUTPUT SAAT SWITCH AKTIF - NO: 0, NC: 1

//PENGATURAN RASIO GERIGI
#define MOTOR_GEAR_TEETH 20.0 // 20.0 UNTUK VERSI BELT 20SFFACTORY   9.0 UNTUK VERSI GERIGI FTOBLER
#define MAIN_GEAR_TEETH 90.0 // 90.0 UNTUK VERSI BELT 20SFFACTORY   32.0 UNTUK VERSI GERIGI FTOBLER

//PENGATURAN PERALATAN
#define VACUM_DELAY_ON 300 // DURASI VACUM ON SEBELUM BERGERAK LAGI
#define VACUM_DELAY_OFF 500 // DURASI VACUM OFF SEBELUM BERGERAK LAGI
#define FAN_DELAY 1000 // DURASI FAN MENYALA DALAM DETIK

#define MAX_SERVO 160
#define MIN_SERVO 95

//PENGATURAN ANTRIAN PERINTAH
#define QUEUE_SIZE 15

//PENGATURAN BALASAN CETAK
#define PRINT_REPLY true // "true" UNTUK MENCETAK PESAN SETELAH SATU PERINTAH DIPROSES
#define PRINT_REPLY_MSG "ok" // PESAN YANG DIKIRIM UNTUK PEMROSESAN LANJUT DENGAN SOFTWARE LAIN

//PENGATURAN PROFIL KECEPATAN DEFAULT 
#define SPEED_PROFILE 2 // PILIHAN DIBAWAH
//0: KURVA KECEPATAN DATAR (KECEPATAN KONSTAN PER GERAKAN, COCOK UNTUK SOFTWARE KONTROL REAL-TIME)
//1: APROKSIMASI ARCTAN (AKSELERASI & DESELERASI KURVA LONCENG RINGAN)
//2: APROKSIMASI COSIN (AKSELERASI PENUH DARI 0 & DESELERASI KE 0, COCOK UNTUK GERAKAN PERINTAH PRESET)

//PENGATURAN LOG
#define LOG_LEVEL 2
//0: ERROR
//1: INFO
//2: DEBUG

//PARAMETER BATAS GERAK
#define Z_MIN -140.0 //TINGGI Z MINIMUM UJUNG TOOL MENYENTUH LANTAI
#define Z_MAX (LOW_SHANK_LENGTH+70.0) //PANJANG SHANK DITAMBAH ANGKA ACAK UNTUK Z_MAX
#define SHANKS_MIN_ANGLE_COS 0.791436948 
#define SHANKS_MAX_ANGLE_COS -0.774944489 
#define R_MIN (sqrt((sq(LOW_SHANK_LENGTH) + sq(HIGH_SHANK_LENGTH)) - (2*LOW_SHANK_LENGTH*HIGH_SHANK_LENGTH*SHANKS_MIN_ANGLE_COS) ))
#define R_MAX (sqrt((sq(LOW_SHANK_LENGTH) + sq(HIGH_SHANK_LENGTH)) - (2*LOW_SHANK_LENGTH*HIGH_SHANK_LENGTH*SHANKS_MAX_ANGLE_COS) ))

#endif


file 4: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\desktop.ini
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\76.0.3.0\GoogleDriveFS.exe,23


file 5: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\endstop.cpp
#include "endstop.h"
#include <Arduino.h>

Endstop::Endstop(int a_min_pin, int a_dir_pin, int a_step_pin, int a_en_pin, int a_switch_input, int a_step_offset, int a_home_dwell, bool does_swap_pin){
  min_pin = a_min_pin;
  dir_pin = a_dir_pin;
  step_pin = a_step_pin;
  en_pin = a_en_pin;
  switch_input = a_switch_input;
  home_dwell = a_home_dwell;
  step_offset = a_step_offset;
  swap_pin = does_swap_pin;
  if (swap_pin == false){
    pinMode(min_pin, INPUT_PULLUP);   
  }
}

void Endstop::home(bool dir) {
  if (swap_pin == true){
    pinMode(min_pin, INPUT_PULLUP);
    delayMicroseconds(5);
  }
  digitalWrite(en_pin, LOW);
  delayMicroseconds(5);
  if (dir==1){
    digitalWrite(dir_pin, HIGH);
  } else {
    digitalWrite(dir_pin, LOW);
  }
  delayMicroseconds(5);
  bState = !(digitalRead(min_pin) ^ switch_input);
  while (!bState) {
    digitalWrite(step_pin, HIGH);
    digitalWrite(step_pin, LOW);
    delayMicroseconds(home_dwell);
    bState = !(digitalRead(min_pin) ^ switch_input);
  }
  homeOffset(dir);
  if (swap_pin == true){
    pinMode(min_pin, OUTPUT);
    delayMicroseconds(5);
  }
}

void Endstop::homeOffset(bool dir){
  if (dir==1){
    digitalWrite(dir_pin, LOW);
  }
  else{
    digitalWrite(dir_pin, HIGH);
  }
  delayMicroseconds(5);
  for (int i = 1; i <= step_offset; i++) {
    digitalWrite(step_pin, HIGH);
    digitalWrite(step_pin, LOW);
    delayMicroseconds(home_dwell);
  }
}

void Endstop::oneStepToEndstop(bool dir){
  if (swap_pin == true){
    pinMode(min_pin, INPUT_PULLUP);
  }
  digitalWrite(en_pin, LOW);
  delayMicroseconds(5);
  if (dir==1){
    digitalWrite(dir_pin, HIGH);
  } else {
    digitalWrite(dir_pin, LOW);
  }
  delayMicroseconds(5);
  bState = !(digitalRead(min_pin) ^ switch_input);

  if (!bState) {
    digitalWrite(step_pin, HIGH);
    digitalWrite(step_pin, LOW);
    delayMicroseconds(home_dwell);
  }
  bState = !(digitalRead(min_pin) ^ switch_input);
}

bool Endstop::state(){
  if (swap_pin == true){
    pinMode(min_pin, INPUT_PULLUP);
    delayMicroseconds(5);
  }
  bState = !(digitalRead(min_pin) ^ switch_input);
  if (swap_pin == true){
    pinMode(min_pin, OUTPUT);
    delayMicroseconds(5);
  }
  return bState;
}

file 6: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\endstop.h
#ifndef ENDSTOP_H_
#define ENDSTOP_H_

class Endstop {
  public:
    Endstop(int a_min_pin, int a_dir_pin, int a_step_pin, int a_en_pin, int a_switch_input, int a_step_offset, int a_home_dwell, bool does_swap_pin);
    void home(bool dir);
    void homeOffset(bool dir);
    void oneStepToEndstop(bool dir);
    bool state();
    bool bState;

  private:
    int min_pin;
    int dir_pin;
    int step_pin;
    int en_pin;
    int switch_input;
    int home_dwell;
    int step_offset;
    bool swap_pin;    
};

#endif


file 7: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\equipment.cpp
#include "equipment.h"
#include <Arduino.h>

Equipment::Equipment(int equipment_pin){
  pin = equipment_pin;
  pinMode(pin, OUTPUT);
}

void Equipment::cmdOn(){
  digitalWrite(pin, HIGH);  
}

void Equipment::cmdOff(){
  digitalWrite(pin, LOW);  
}


file 8: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\equipment.h
#ifndef EQUIPMENT_H_
#define EQUIPMENT_H_

class Equipment {
public:
  Equipment(int equipment_pin);
  void cmdOn();
  void cmdOff();
private:
  int pin;
};

#endif


file 9: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\fanControl.cpp
#include "fanControl.h"
#include <Arduino.h>


FanControl::FanControl(int aPin, int aFanDelay) {
  fan_delay = aFanDelay * 1000;
  nextShutdown = 0;
  pin = aPin;
  pinMode(pin , OUTPUT);
  digitalWrite(pin , LOW);
  state = false;
}

void FanControl::enable(bool value) {
  if (value) {
    state = true;
    digitalWrite(pin, HIGH);
  } else {
    disable();
  }
}

void FanControl::disable() {
  state = false;
  nextShutdown = millis() + fan_delay;
  update();
}

void FanControl::update() {
  if (!state) {
     if (millis() >= nextShutdown) {
       digitalWrite(pin, LOW);
     }
  }
}


file 10: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\fanControl.h
#ifndef FANCONTROL_H_
#define FANCONTROL_H_

class FanControl {
public:
  FanControl(int aPin, int aFanDelay);
  void enable(bool value = true);
  void disable();
  void update();
private:
  bool state;
  int pin;
  long fan_delay;
  long nextShutdown;
};

#endif


file 11: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\Info update.txt
26/03/2025
1. Bisa request status sensor (M105)
    kirim "M105" ke serial untuk melihat status sensor

file 12: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\interpolation.cpp
#include "interpolation.h"
#include "config.h"
#include "queue.h"
#include "logger.h"

Interpolation::Interpolation(){
  speed_profile = SPEED_PROFILE;
  pos_offset.xmm = 0.0;
  pos_offset.ymm = 0.0;
  pos_offset.zmm = 0.0;
  pos_offset.emm = 0.0;
}

void Interpolation::setSpeedProfile(int new_speed_profile){
  speed_profile = new_speed_profile;
}

//G92 POSITION OFFSET FUNCTIONS
void Interpolation::setPosOffset(float new_x, float new_y, float new_z, float new_e) {
  pos_offset.xmm = xPosmm - new_x;
  pos_offset.ymm = yPosmm - new_y;
  pos_offset.zmm = zPosmm - new_z;
  pos_offset.emm = ePosmm - new_e;
  Logger::logINFO("POSITION OFFSET: [X" + String(pos_offset.xmm) + " Y:" + String(pos_offset.ymm) + " Z:" + String(pos_offset.zmm) + " E:" + String(pos_offset.emm) + "]");
  Logger::logINFO("CURRENT POSITION: [X:"+String(new_x)+" Y:"+String(new_y)+" Z:"+String(new_z)+" E:"+String(new_e)+"]");
}

void Interpolation::resetPosOffset(){
  pos_offset.xmm = 0.0;
  pos_offset.ymm = 0.0;
  pos_offset.zmm = 0.0;
  pos_offset.emm = 0.0;
}

Point Interpolation::getPosOffset() const {
  return pos_offset;
}


void Interpolation::setCurrentPos(float px, float py, float pz, float pe) {
  Point p;
  p.xmm = px;
  p.ymm = py;
  p.zmm = pz;
  p.emm = pe;
  setCurrentPos(p);
}

void Interpolation::setInterpolation(float px, float py, float pz, float pe, float v) {
  Point p;
  p.xmm = px;
  p.ymm = py;
  p.zmm = pz;
  p.emm = pe;
  setInterpolation(p, v);
}

void Interpolation::setInterpolation(float p1x, float p1y, float p1z, float p1e, float p2x, float p2y, float p2z, float p2e, float v) {
  Point p1;
  Point p2;
  p1.xmm = p1x;
  p1.ymm = p1y;
  p1.zmm = p1z;
  p1.emm = p1e;
  p2.xmm = p2x;
  p2.ymm = p2y;
  p2.zmm = p2z;
  p2.emm = p2e;
  setInterpolation(p1, p2, v);
}

void Interpolation::setInterpolation(Point p1, float v) {
  Point p0;
  p0.xmm = xStartmm + xDelta;
  p0.ymm = yStartmm + yDelta;
  p0.zmm = zStartmm + zDelta;
  p0.emm = eStartmm + eDelta;
  setInterpolation(p0, p1, v);
}

void Interpolation::setInterpolation(Point p0, Point p1, float av) {
  v = av; //mm/s
  
  float a = (p1.xmm - p0.xmm);
  float b = (p1.ymm - p0.ymm);
  float c = (p1.zmm - p0.zmm);
  float e = abs(p1.emm - p0.emm);
  float dist = sqrt(a*a + b*b + c*c);

  if (dist < e) {
    dist = e; 
  }

  if (v < 5) { //includes 0 = default value
    v = sqrt(dist) * 10; //set a good value for v
  }
  if (v < 5) {
     v = 5; 
  }
  
  tmul = v / dist;
  
  xStartmm = p0.xmm;
  yStartmm = p0.ymm;
  zStartmm = p0.zmm;
  eStartmm = p0.emm;
  
  xDelta = (p1.xmm - p0.xmm);
  yDelta = (p1.ymm - p0.ymm);
  zDelta = (p1.zmm - p0.zmm);
  eDelta = (p1.emm - p0.emm);
   
  state = 0;
  
  startTime = micros();
}

void Interpolation::setCurrentPos(Point p) {
  xStartmm = p.xmm;
  yStartmm = p.ymm;
  zStartmm = p.zmm;
  eStartmm = p.emm;
  xDelta = 0;
  yDelta = 0;
  zDelta = 0;
  eDelta = 0;
}

void Interpolation::updateActualPosition() {
  if (state != 0) {
    return;
  }    
  long microsek = micros();
  float t = (microsek - startTime) / 1000000.0;
  float progress;
  switch (speed_profile){
    // FLAT SPEED CURVE
    case 0:
      progress = t * tmul;
      if (progress >= 1.0){
        progress = 1.0;
        state = 1;
      }
      break;
    // ARCTAN APPROX
    case 1:
      progress = atan((PI * t * tmul) - (PI * 0.5)) * 0.5 + 0.5;
      if (progress >= 1.0) {
        progress = 1.0; 
        state = 1;
      }
      break;
    // COSIN APPROX
    case 2:
      progress = -cos(t * tmul * PI) * 0.5 + 0.5;
      if ((t * tmul) >= 1.0) {
        progress = 1.0; 
        state = 1;
      }
      break;
  }
  pos_tracker[X_AXIS] = xStartmm + progress * xDelta;
  pos_tracker[Y_AXIS] = yStartmm + progress * yDelta;
  pos_tracker[Z_AXIS] = zStartmm + progress * zDelta;
  pos_tracker[E_AXIS] = eStartmm + progress * eDelta;

  if(isAllowedPosition(pos_tracker)){
    xPosmm = pos_tracker[X_AXIS];
    yPosmm = pos_tracker[Y_AXIS];
    zPosmm = pos_tracker[Z_AXIS];
    ePosmm = pos_tracker[E_AXIS];
  } else {
    pos_tracker[X_AXIS] = xPosmm;
    pos_tracker[Y_AXIS] = yPosmm;
    pos_tracker[Z_AXIS] = zPosmm;
    pos_tracker[E_AXIS] = ePosmm;
    state = 1;
    progress = 1.0;
    xStartmm = xPosmm;
    yStartmm = yPosmm;
    zStartmm = zPosmm;
    eStartmm = ePosmm;
    xDelta = 0;
    yDelta = 0;
    zDelta = 0;
    eDelta = 0;
  }
  //FOR DECIPHERING SPEED CURVE
  //Serial.print("xPosmm:");
  //Serial.print(xPosmm);
  //Serial.print(" yPosmm:");
  //Serial.print(yPosmm);
  //Serial.print(" zPosmm:");
  //Serial.println(zPosmm);
}

bool Interpolation::isFinished() const {
  return state != 0; 
}

float Interpolation::getXPosmm() const {
  return xPosmm;
}

float Interpolation::getYPosmm() const {
  return yPosmm;
}

float Interpolation::getZPosmm() const {
  return zPosmm;
}

float Interpolation::getEPosmm() const {
  return ePosmm;
}

Point Interpolation::getPosmm() const {
  Point p;
  p.xmm = xPosmm;
  p.ymm = yPosmm;
  p.zmm = zPosmm;
  p.emm = ePosmm;
  return p;
}

bool Interpolation::isAllowedPosition(float pos_tracker[4]) {
  float rrot_ee = hypot(pos_tracker[X_AXIS], pos_tracker[Y_AXIS]);
  float rrot = rrot_ee - END_EFFECTOR_OFFSET; 
  float rrot_x = rrot * (pos_tracker[Y_AXIS] / rrot_ee);
  float rrot_y = rrot * (pos_tracker[X_AXIS] / rrot_ee);
  float squaredPositionModule = sq(rrot_x) + sq(rrot_y) + sq(pos_tracker[Z_AXIS]);  

      bool retVal = (
          squaredPositionModule <= sq(R_MAX) 
          && squaredPositionModule >= sq(R_MIN) 
          && pos_tracker[Z_AXIS] >= Z_MIN  
          && pos_tracker[Z_AXIS] <= Z_MAX 
          #if RAIL
          && pos_tracker[E_AXIS] <= RAIL_LENGTH
          && pos_tracker[E_AXIS] >= 0
          #endif
      );
  if(!retVal) {
    Logger::logERROR("LIMIT REACHED: [X:" + String(pos_tracker[X_AXIS]) + " Y:" + String(pos_tracker[Y_AXIS]) + " Z:" + String(pos_tracker[Z_AXIS]) + " E:" + String(pos_tracker[E_AXIS]) + "]");
  }
  return retVal;
}


file 13: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\interpolation.h
#ifndef INTERPOLATION_H_
#define INTERPOLATION_H_
#include <Arduino.h>

#define X_AXIS 0
#define Y_AXIS 1
#define Z_AXIS 2
#define E_AXIS 3

struct Point {
  float xmm;
  float ymm;
  float zmm;
  float emm;
};
class Interpolation {
public:
  //void resetInterpolation(float px, float py, float pz);
  //void resetInterpolation(float p1x, float p1y, float p1z, float p2x, float p2y, float p2z);
  //void resetInterpolation(Point p0, Point p1);
  Interpolation();
  void setCurrentPos(float px, float py, float pz, float pe);
  void setInterpolation(float px, float py, float pz, float pe, float v = 0);
  void setInterpolation(float p1x, float p1y, float p1z, float p1e, float p2x, float p2y, float p2z, float p2e, float av = 0);
  
  void setCurrentPos(Point p);
  void setInterpolation(Point p1, float v = 0);
  void setInterpolation(Point p0, Point p1, float v = 0);
  
  void updateActualPosition();
  bool isFinished() const;
  
  float getXPosmm() const;
  float getYPosmm() const;
  float getZPosmm() const;
  float getEPosmm() const;
  Point getPosmm() const;
  bool isAllowedPosition(float pos_tracker[4]);
  void setPosOffset(float new_x, float new_y, float new_z, float new_e);
  void resetPosOffset();
  Point getPosOffset() const;
  int speed_profile;
  void setSpeedProfile(int new_speed_profile);
  
private:
  Point pos_offset;
  float pos_tracker[4];
  byte state;
  
  long startTime;  
  
  float xStartmm;
  float yStartmm;
  float zStartmm;
  float eStartmm;
  float xDelta;
  float yDelta;
  float zDelta;
  float eDelta;
  float xPosmm;
  float yPosmm;
  float zPosmm;
  float ePosmm;
  float v;
  float tmul;
};

#endif


file 14: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\logger.cpp
#include "config.h"
#include "logger.h"

void Logger::log(String message, int level) {
  if(LOG_LEVEL >= level) {
    String logMsg;
    switch(level) {
      case LOG_ERROR:
        logMsg = "ERROR: ";
      break;
      case LOG_INFO:
        //logMsg = "INFO: ";
        logMsg;
      break;
      case LOG_DEBUG:
        logMsg = "DEBUG: ";
      break;
    }
    logMsg = logMsg + message;
    Serial.println(logMsg);
  }
}

void Logger::logERROR(String message) {
  log(message, LOG_ERROR);
}
void Logger::logINFO(String message) {
  log(message, LOG_INFO);
}
void Logger::logDEBUG(String message) {
  log(message, LOG_DEBUG);
}

file 15: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\logger.h
#ifndef LOGGER_H_
#define LOGGER_H_

#include <Arduino.h>

#define LOG_ERROR 0
#define LOG_INFO 1
#define LOG_DEBUG 2

class Logger {
  public:
    static void log(String message, int level);
    static void logINFO(String message);
    static void logERROR(String message);
    static void logDEBUG(String message);
};
#endif


file 16: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\queue.h
#ifndef QUEUE_H_
#define QUEUE_H_

template <typename Element> class Queue {
public:
  Queue(int alen);
  ~Queue();
  bool push(Element elem);
  Element pop();
  bool isFull() const;
  bool isEmpty() const;
  int getFreeSpace() const;
  int getMaxLength() const;
  inline int getUsedSpace() const;
private:
  Queue(Queue<Element>& q);  //copy const.
  Element* data;
  int len;
  int start;
  int count;
};

template <typename Element>
Queue<Element>::Queue(int alen) {
  data = new Element[alen];
  len = alen;
  start = 0;
  count = 0;
}

template <typename Element>
Queue<Element>::~Queue() {
  delete data;
}

template <typename Element>
Queue<Element>::Queue(Queue<Element>& q) {
  //nothing ever is allowed to do something here
}

template <typename Element>
bool Queue<Element>::push(Element elem) {
  data[(start + count++) % len] = elem;
}

template <typename Element>
Element Queue<Element>::pop() {
  count--;
  int s = start;
  start = (start + 1) % len;
  return data[(s) % len];
}

template <typename Element>
bool Queue<Element>::isFull() const {
  return count >= len;
}

template <typename Element>
bool Queue<Element>::isEmpty() const {
  return count <= 0;
}

template <typename Element>
int Queue<Element>::getFreeSpace() const {
  return len - count;
}

template <typename Element>
int Queue<Element>::getMaxLength() const {
  return len;
}

template <typename Element>
int Queue<Element>::getUsedSpace() const {
  return count;
}

#endif


file 17: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\RampsStepper.cpp
#include <Arduino.h>
#include "RampsStepper.h"

RampsStepper::RampsStepper(int aStepPin, int aDirPin, int aEnablePin, bool aInverse, float main_gear_teeth, float motor_gear_teeth, int microsteps, int steps_per_rev) {
  setReductionRatio(main_gear_teeth / motor_gear_teeth, microsteps * steps_per_rev);
  stepPin = aStepPin;
  dirPin = aDirPin;
  enablePin = aEnablePin;
  inverse = aInverse;
  stepperStepPosition = 0;
  stepperStepTargetPosition;
  pinMode(stepPin, OUTPUT);
  pinMode(dirPin, OUTPUT);
  pinMode(enablePin, OUTPUT);
  enable(false);
}

void RampsStepper::enable(bool value) {
  digitalWrite(enablePin, !value);
}

bool RampsStepper::isOnPosition() const {
  return stepperStepPosition == stepperStepTargetPosition;
}

int RampsStepper::getPosition() const {
  return stepperStepPosition;
}

void RampsStepper::setPosition(int value) {
  stepperStepPosition = value;
  stepperStepTargetPosition = value;
}

void RampsStepper::stepToPosition(int value) {
  stepperStepTargetPosition = value;
}

void RampsStepper::stepToPositionMM(float mm, float steps_per_mm) {
  stepperStepTargetPosition = mm * steps_per_mm;
}

void RampsStepper::stepRelative(int value) {
  value += stepperStepPosition;
  stepToPosition(value);
}

float RampsStepper::getPositionRad() const {
  return stepperStepPosition / radToStepFactor;
}

void RampsStepper::setPositionRad(float rad) {
  setPosition(rad * radToStepFactor);
}

void RampsStepper::stepToPositionRad(float rad) {
  stepperStepTargetPosition = rad * radToStepFactor;
}

void RampsStepper::stepRelativeRad(float rad) {
  stepRelative(rad * radToStepFactor);
}

void RampsStepper::update() {   
  while (stepperStepTargetPosition < stepperStepPosition) {  
    digitalWrite(dirPin, !inverse);
    digitalWrite(stepPin, HIGH);
    digitalWrite(stepPin, LOW);
    stepperStepPosition--;
  }
  
  while (stepperStepTargetPosition > stepperStepPosition) {    
    digitalWrite(dirPin, inverse);
    digitalWrite(stepPin, HIGH);
    digitalWrite(stepPin, LOW);
    stepperStepPosition++;
  }
}

void RampsStepper::setReductionRatio(float gearRatio, int stepsPerRev) {
  radToStepFactor = gearRatio * stepsPerRev / 2 / PI;
};


file 18: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\RampsStepper.h
#ifndef RAMPSSTEPPER_H_
#define RAMPSSTEPPER_H_

class RampsStepper {
public:
  RampsStepper(int aStepPin, int aDirPin, int aEnablePin, bool aInverse, float main_gear_teeth, float motor_gear_teeth, int microsteps, int steps_per_rev);
  void enable(bool value = true);
    
  bool isOnPosition() const;
  int getPosition() const;
  void setPosition(int value);
  void stepToPosition(int value);
  void stepToPositionMM(float mm, float steps_per_mm);
  void stepRelative(int value);
  float getPositionRad() const;
  void setPositionRad(float rad);
  void stepToPositionRad(float rad);
  void stepRelativeRad(float rad);
  
  void update();
  
  void setReductionRatio(float gearRatio, int stepsPerRev);
private:
  int stepperStepTargetPosition;
  int stepperStepPosition;
  int stepPin;
  int dirPin;
  int enablePin;  
  bool inverse;
  float radToStepFactor;
};

#endif


file 19: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\robotGeometry.cpp
#include "robotGeometry.h"

#include <math.h>
#include <Arduino.h>

RobotGeometry::RobotGeometry(float a_ee_offset, float a_low_shank_length, float a_high_shank_length) {
  ee_offset = a_ee_offset;
  low_shank_length = a_low_shank_length;
  high_shank_length = a_high_shank_length;
}

void RobotGeometry::set(float axmm, float aymm, float azmm) {
  xmm = axmm;
  ymm = aymm;
  zmm = azmm; 
  calculateGrad();
}

float RobotGeometry::getXmm() const {
  return xmm;
}

float RobotGeometry::getYmm() const {
  return ymm;
}

float RobotGeometry::getZmm() const {
  return zmm;
}

float RobotGeometry::getRotRad() const {
  return rot;
}

float RobotGeometry::getLowRad() const {
  return low;
}

float RobotGeometry::getHighRad() const {
  return high;
}

float RobotGeometry::getHypot() const {
  return rrot_ee;
}

void RobotGeometry::calculateGrad() {
   rrot_ee =  hypot(xmm, ymm);    
   float rrot = rrot_ee - ee_offset; //radius from Top View
   float rside = hypot(rrot, zmm);  //radius from Side View. Use rrot instead of ymm..for everything
   float rside_2 = sq(rside);
   float low_2 = sq(low_shank_length);
   float high_2 = sq(high_shank_length);
   
   rot = asin(xmm / rrot_ee);
   high = PI - acos((low_2 + high_2 - rside_2) / (2 * low_shank_length * high_shank_length));

   //Angle of Lower Stepper Motor  (asin()=Angle To Gripper)
   if (zmm > 0) {
     low =  acos(zmm / rside) - acos((low_2 - high_2 + rside_2) / (2 * low_shank_length * rside));
   } else {
     low = PI - asin(rrot / rside) - acos((low_2 - high_2 + rside_2) / (2 * low_shank_length * rside));
   }
   high = high + low;
}


file 20: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\robotGeometry.h
#ifndef ROBOTGEOMETRY_H_
#define ROBOTGEOMETRY_H_

class RobotGeometry {
public:
  RobotGeometry(float a_ee_offset, float a_low_shank_length, float a_high_length);
  void set(float axmm, float aymm, float azmm);
  float getXmm() const;
  float getYmm() const;
  float getZmm() const;
  float getRotRad() const;
  float getLowRad() const;
  float getHighRad() const;
  float getHypot() const;
private:
  void calculateGrad();
  float ee_offset;
  float low_shank_length;
  float high_shank_length;
  float xmm;
  float ymm;
  float zmm;
  float rot;
  float low;
  float high;
  float rrot_ee;
};

#endif


file 21: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\robotRNV3_v2_02.ino
#include <Arduino.h>
//GENERAL CONFIG SETTINGS
#include "config.h"

#include "robotGeometry.h"
#include "interpolation.h"
#include "RampsStepper.h"
#include "queue.h"
#include "command.h"
#include "equipment.h"
#include "endstop.h"
#include "logger.h"
#include "fanControl.h"
#include <Servo.h>
#include "pinout/pinout.h"

int targetServoA = -1;
int targetServoB = -1;
bool waitingForServo = false;
unsigned long servoMoveStartTime = 0;
int servoMoveDuration = 0;  // Waktu estimasi servo sampai target (ms)


//STEPPER OBJECTS
RampsStepper stepperHigher(X_STEP_PIN, X_DIR_PIN, X_ENABLE_PIN, INVERSE_X_STEPPER, MAIN_GEAR_TEETH, MOTOR_GEAR_TEETH, MICROSTEPS, STEPS_PER_REV);
RampsStepper stepperLower(Y_STEP_PIN, Y_DIR_PIN, Y_ENABLE_PIN, INVERSE_Y_STEPPER, MAIN_GEAR_TEETH, MOTOR_GEAR_TEETH, MICROSTEPS, STEPS_PER_REV);
RampsStepper stepperRotate(Z_STEP_PIN, Z_DIR_PIN, Z_ENABLE_PIN, INVERSE_Z_STEPPER, MAIN_GEAR_TEETH, MOTOR_GEAR_TEETH, MICROSTEPS, STEPS_PER_REV);

//RAIL OBJECTS
#if RAIL
  RampsStepper stepperRail(E0_STEP_PIN, E0_DIR_PIN, E0_ENABLE_PIN, INVERSE_E0_STEPPER, MAIN_GEAR_TEETH, MOTOR_GEAR_TEETH, MICROSTEPS, STEPS_PER_REV);
  Endstop endstopE0(E0_MIN_PIN, E0_DIR_PIN, E0_STEP_PIN, E0_ENABLE_PIN, E0_MIN_INPUT, E0_HOME_STEPS, HOME_DWELL, false);
#endif

//ENDSTOP OBJECTS
Endstop endstopX(X_MIN_PIN, X_DIR_PIN, X_STEP_PIN, X_ENABLE_PIN, X_MIN_INPUT, X_HOME_STEPS, HOME_DWELL, false);
Endstop endstopY(Y_MIN_PIN, Y_DIR_PIN, Y_STEP_PIN, Y_ENABLE_PIN, Y_MIN_INPUT, Y_HOME_STEPS, HOME_DWELL, false);
Endstop endstopZ(Z_MIN_PIN, Z_DIR_PIN, Z_STEP_PIN, Z_ENABLE_PIN, Z_MIN_INPUT, Z_HOME_STEPS, HOME_DWELL, false);


Equipment lg1(LG1_PIN);
Equipment lg2(LG2_PIN);
Equipment lg3(LG3_PIN);
Equipment led(LED_PIN);
FanControl fan(FAN_PIN, FAN_DELAY);

//EXECUTION & COMMAND OBJECTS
RobotGeometry geometry(END_EFFECTOR_OFFSET, LOW_SHANK_LENGTH, HIGH_SHANK_LENGTH);
Interpolation interpolator;
Queue<Cmd> queue(QUEUE_SIZE);
Command command;

//---------------------------------IO-------------------------------------------
int IO1Before = LOW;
int IO2Before = LOW;
int IO3Before = LOW;
//------------------------------------------------------------------------------

Servo servoA;
Servo servoB;

static bool waitingForMotion = false;

void setup() {
  Serial.begin(BAUD);
  stepperHigher.setPositionRad(PI / 2.0); // 90°
  stepperLower.setPositionRad(0);         // 0°
  stepperRotate.setPositionRad(0);        // 0°
  #if RAIL
  stepperRail.setPosition(0);
  #endif

  Logger::logINFO("SETUP GRIPPER SERVO : MIN " + String(MIN_SERVO) + " MAX " + String(MAX_SERVO));
  delay(50);

  if (HOME_ON_BOOT) {
    homeSequence(); 
    Logger::logINFO("ROBOT ONLINE");
  } else {
    setStepperEnable(false);
    if (RAIL) {
      delay(100);
      Logger::logINFO("RAIL ON");
    } else {
      delay(100);  
      Logger::logINFO("RAIL OFF");
    }
    if (HOME_X_STEPPER && HOME_Y_STEPPER && !HOME_Z_STEPPER){
      Logger::logINFO("PUTAR ROBOT KE DEPAN TENGAH & KIRIM G28 UNTUK KALIBRASI");
    }
    if (HOME_X_STEPPER && HOME_Y_STEPPER && HOME_Z_STEPPER){
      delay(100);
      Logger::logINFO("READY CALIBRATION");
    }
    if (!HOME_X_STEPPER && !HOME_Y_STEPPER){
      Logger::logINFO("HOME ROBOT MANUALLY & SEND G28 TO CALIBRATE");
    }
  }
  interpolator.setInterpolation(INITIAL_X, INITIAL_Y, INITIAL_Z, INITIAL_E0, INITIAL_X, INITIAL_Y, INITIAL_Z, INITIAL_E0);
  
//-------------------------------------IO------------------------------------------------
  pinMode(IO1_PIN, INPUT);
  pinMode(IO2_PIN, INPUT);
  pinMode(IO3_PIN, INPUT);
//-----------------------------------------------------------------------------------------
  lg1.cmdOff();
  lg2.cmdOff();
  lg3.cmdOff();
  servoA.attach(SERVO_PIN_A);  // Pin Servo A
  servoB.attach(SERVO_PIN);  // Pin Servo B
  servoA.write(90);  // Set awal ke 50°
  servoB.write(MAX_SERVO);  // Set awal ke 50°
}

void loop() {

  interpolator.updateActualPosition();
  geometry.set(interpolator.getXPosmm(), interpolator.getYPosmm(), interpolator.getZPosmm());
  stepperRotate.stepToPositionRad(geometry.getRotRad());
  stepperLower.stepToPositionRad(geometry.getLowRad());
  stepperHigher.stepToPositionRad(geometry.getHighRad());
  #if RAIL
    stepperRail.stepToPositionMM(interpolator.getEPosmm(), STEPS_PER_MM_RAIL);
  #endif
  stepperRotate.update();
  stepperLower.update();
  stepperHigher.update();
  #if RAIL
    stepperRail.update();
  #endif
  fan.update();

  // Jika antrean perintah tidak penuh dan tidak sedang menunggu gerakan, ambil perintah baru
  if (!queue.isFull() && !waitingForMotion && !waitingForServo) {
      if (command.handleGcode()) {
          queue.push(command.getCmd());
      }
  }

  // Jika ada perintah dalam antrean dan gerakan sebelumnya selesai, eksekusi perintah
  if (!queue.isEmpty() && interpolator.isFinished() && !waitingForMotion && !waitingForServo) {
      Cmd currentCmd = queue.pop();
      executeCommand(currentCmd);
      
      // Hanya set waitingForMotion jika bukan perintah M208
      if (!(currentCmd.id == 'M' && currentCmd.num == 208)) {
          waitingForMotion = true;
      }
  }

  // Kirim "ok" setelah motor stepper selesai bergerak
if (waitingForMotion && interpolator.isFinished()) {
    if (!waitingForServo) {  // Pastikan servo tidak bergerak sebelum mengirim "ok"
        if (PRINT_REPLY) {
          Serial.println(PRINT_REPLY_MSG);
        }
        waitingForMotion = false;  // Reset flag setelah stepper selesai
    }
}

// Kirim "ok" setelah servo selesai bergerak
if (waitingForServo && (millis() - servoMoveStartTime >= servoMoveDuration)) {
    waitingForServo = false;  // Reset flag setelah servo selesai
    targetServoA = -1;
    targetServoB = -1;
}

//-----------------------------------------------------------------------------

  if (millis() % 500 < 250) {
    led.cmdOn();
  }
  else {
    led.cmdOff();
  }

 //============== SENSOR =======================================================
  if (digitalRead(IO1_PIN) == HIGH && IO1Before == LOW) {
      Logger::logINFO("S1 ON");
      IO1Before = HIGH;
  } else if (digitalRead(IO1_PIN) == LOW && IO1Before == HIGH) {
      Logger::logINFO("S1 OFF");
      IO1Before = LOW;
  }

  if (digitalRead(IO2_PIN) == HIGH && IO2Before == LOW) {
      Logger::logINFO("S2 ON");
      IO2Before = HIGH;
  } else if (digitalRead(IO2_PIN) == LOW && IO2Before == HIGH) {
      Logger::logINFO("S2 OFF");
      IO2Before = LOW;
  }

  if (digitalRead(IO3_PIN) == HIGH && IO3Before == LOW) {
      Logger::logINFO("S3 ON");
      IO3Before = HIGH;
  } else if (digitalRead(IO3_PIN) == LOW && IO3Before == HIGH) {
      Logger::logINFO("S3 OFF");
      IO3Before = LOW;
  }
}


void executeCommand(Cmd cmd) {

  if (cmd.id == -1) {
    printErr();
    return;
  }

  if (cmd.id == 'G') {
    switch (cmd.num) {
    case 0:
    case 1:
            fan.enable(true);
            Point posoffset;
            posoffset = interpolator.getPosOffset();      
            cmdMove(cmd, interpolator.getPosmm(), posoffset, command.isRelativeCoord);
            interpolator.setInterpolation(cmd.valueX, cmd.valueY, cmd.valueZ, cmd.valueE, cmd.valueF);
            Logger::logINFO("LINEAR MOVE: [X:" + String(cmd.valueX-posoffset.xmm) + " Y:" + String(cmd.valueY-posoffset.ymm) + " Z:" + String(cmd.valueZ-posoffset.zmm) + " E:" + String(cmd.valueE-posoffset.emm)+"]");
    case 4: cmdDwell(cmd); break;
    case 28:  homeSequence(); break;  // Hapus pilihan board lain, hanya gunakan sequence untuk Mega
    case 90:  command.cmdToAbsolute(); break; // ABSOLUTE COORDINATE MODE
    case 91:  command.cmdToRelative(); break; // RELATIVE COORDINATE MODE
    case 92:  interpolator.resetPosOffset(); cmdMove(cmd, interpolator.getPosmm(), interpolator.getPosOffset(), false);
              interpolator.setPosOffset(cmd.valueX, cmd.valueY, cmd.valueZ, cmd.valueE); break;
    case 100: {  // G100: Gerakan Servo
              String logMessage = "SERVO MOVE: [";
              bool firstValue = true;

              float waktuPerDerajat = 5;
              float waktuA = 0, waktuB = 0;

              // Cek dan proses cmd.valueA
              if (!isnan(cmd.valueA) && cmd.valueA >= 0 && cmd.valueA <= 180) {
                  float posisiSekarangA = servoA.read();  // Baca posisi saat ini
                  float deltaA = abs(cmd.valueA - posisiSekarangA); // Hitung selisih sudut
                  waktuA = deltaA * waktuPerDerajat; // Hitung estimasi waktu

                  servoA.write(cmd.valueA);
                  logMessage += "A:" + String(cmd.valueA, 2);
                  firstValue = false;
                  targetServoA = cmd.valueA;  
              } else {
                  Serial.println("Nilai cmd.valueA di luar rentang yang diizinkan!");
              }

              // Cek dan proses cmd.valueB
              if (!isnan(cmd.valueB) && cmd.valueB >= MIN_SERVO && cmd.valueB <= MAX_SERVO) {
                  float posisiSekarangB = servoB.read();  
                  float deltaB = abs(cmd.valueB - posisiSekarangB); 
                  waktuB = deltaB * waktuPerDerajat; 

                  servoB.write(cmd.valueB);
                  if (!firstValue) logMessage += " ";
                  logMessage += "B:" + String(cmd.valueB, 2);
                  targetServoB = cmd.valueB;  
              } else {
                  Serial.println("Nilai cmd.valueB di luar rentang yang diizinkan!");
              }

              logMessage += "]";
              Logger::logINFO(logMessage);

              // Aktifkan flag untuk menunggu servo selesai
              waitingForServo = true;
              servoMoveStartTime = millis();

              // Pilih waktu terlama dari kedua servo agar replay "ok" sesuai
              servoMoveDuration = max(waktuA, waktuB);  

              break;
            }

    default: printErr();
    }
  }
  else if (cmd.id == 'M') {
    switch (cmd.num) {
    case 1: lg1.cmdOn(); break;
    case 2: lg1.cmdOff(); break;
    case 6: lg3.cmdOn(); break;
    case 7: lg3.cmdOff(); break;
    case 17: setStepperEnable(true); break;
    case 18: setStepperEnable(false); break;
    case 105: {
      // Read and report all sensor states
      String sensorStatus = "SENSOR STATUS: [S1:";
      sensorStatus += String(digitalRead(IO1_PIN) == HIGH ? "ON" : "OFF");
      sensorStatus += " S2:";
      sensorStatus += String(digitalRead(IO2_PIN) == HIGH ? "ON" : "OFF");
      sensorStatus += " S3:";
      sensorStatus += String(digitalRead(IO3_PIN) == HIGH ? "ON" : "OFF");
      sensorStatus += "]";
      Logger::logINFO(sensorStatus);
      break;
    }
    case 106: fan.enable(true); break;
    case 107: fan.enable(false); break;
    case 114: command.cmdGetPosition(interpolator.getPosmm(), interpolator.getPosOffset(), stepperHigher.getPosition(), stepperLower.getPosition(), stepperRotate.getPosition()); break;// Return the current positions of all axis 
    case 119: {
      String endstopMsg = "ENDSTOP: [X:";
      endstopMsg += String(endstopX.state());
      endstopMsg += " Y:";
      endstopMsg += String(endstopY.state());
      endstopMsg += " Z:";
      endstopMsg += String(endstopZ.state());
      #if RAIL
        endstopMsg += " E:";
        endstopMsg += String(endstopE0.state());
      #endif
      endstopMsg += "]";
      Logger::logINFO(endstopMsg);
      break;}
    case 205:
      interpolator.setSpeedProfile(cmd.valueS); 
      Logger::logINFO("SPEED PROFILE: [" + String(interpolator.speed_profile) + "]");
      break;
    case 206: lg2.cmdOn(); break;
    case 207: lg2.cmdOff(); break;

    case 208: lg2.cmdOff(); break;

    case 209: {
                lg3.cmdOn(); 
                lg2.cmdOff();
                delay(VACUM_DELAY_ON);
                break;
    }  

    case 230: {
                lg3.cmdOff(); 
                lg2.cmdOn();
                Logger::logINFO("Tunggu..");
                delay(VACUM_DELAY_OFF);
                lg2.cmdOff();
                break;
    }
    
    default: printErr();
    }
  }
  else {
    printErr();
  }
}

void setStepperEnable(bool enable){
  stepperRotate.enable(enable);
  stepperLower.enable(enable);
  stepperHigher.enable(enable);
  #if RAIL
    stepperRail.enable(enable);
  #endif
  fan.enable(enable);
}

void homeSequence(){
  setStepperEnable(false);
  fan.enable(true);
  if (HOME_Y_STEPPER && HOME_X_STEPPER){
    endstopY.home(!INVERSE_Y_STEPPER);
    endstopX.home(!INVERSE_X_STEPPER);
  } else {
    setStepperEnable(true);
    endstopY.homeOffset(!INVERSE_Y_STEPPER);
    endstopX.homeOffset(!INVERSE_X_STEPPER);
  }
  if (HOME_Z_STEPPER){
    endstopZ.home(INVERSE_Z_STEPPER);
  }
  #if RAIL
    if (HOME_E0_STEPPER){
      endstopE0.home(!INVERSE_E0_STEPPER);
    }
  #endif
  interpolator.setInterpolation(INITIAL_X, INITIAL_Y, INITIAL_Z, INITIAL_E0, INITIAL_X, INITIAL_Y, INITIAL_Z, INITIAL_E0);
  Logger::logINFO("HOMING COMPLETE");
}



file 22: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\.vscode\arduino.json
{
    "port": "COM5",
    "configuration": "cpu=atmega2560",
    "board": "arduino:avr:mega",
    "programmer": "arduino:arduinoasisp",
    "sketch": "robotRNV3_v2_06.ino"
}

file 23: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\.vscode\c_cpp_properties.json
{
    "version": 4,
    "configurations": [
        {
            "name": "Arduino",
            "compilerPath": "C:\\Users\\febru\\AppData\\Local\\Arduino15\\packages\\arduino\\tools\\avr-gcc\\7.3.0-atmel3.6.1-arduino7\\bin\\avr-g++",
            "compilerArgs": [
                "-w",
                "-std=gnu++11",
                "-fpermissive",
                "-fno-exceptions",
                "-ffunction-sections",
                "-fdata-sections",
                "-fno-threadsafe-statics",
                "-Wno-error=narrowing"
            ],
            "intelliSenseMode": "gcc-x64",
            "includePath": [
                "C:\\Users\\febru\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.6\\cores\\arduino",
                "C:\\Users\\febru\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.6\\variants\\mega",
                "C:\\Users\\febru\\Documents\\Arduino\\libraries\\Servo\\src",
                "c:\\users\\febru\\appdata\\local\\arduino15\\packages\\arduino\\tools\\avr-gcc\\7.3.0-atmel3.6.1-arduino7\\lib\\gcc\\avr\\7.3.0\\include",
                "c:\\users\\febru\\appdata\\local\\arduino15\\packages\\arduino\\tools\\avr-gcc\\7.3.0-atmel3.6.1-arduino7\\lib\\gcc\\avr\\7.3.0\\include-fixed",
                "c:\\users\\febru\\appdata\\local\\arduino15\\packages\\arduino\\tools\\avr-gcc\\7.3.0-atmel3.6.1-arduino7\\avr\\include"
            ],
            "forcedInclude": [
                "C:\\Users\\febru\\AppData\\Local\\Arduino15\\packages\\arduino\\hardware\\avr\\1.8.6\\cores\\arduino\\Arduino.h"
            ],
            "cStandard": "c11",
            "cppStandard": "c++11",
            "defines": [
                "F_CPU=16000000L",
                "ARDUINO=10607",
                "ARDUINO_AVR_MEGA2560",
                "ARDUINO_ARCH_AVR",
                "__DBL_MIN_EXP__=(-125)",
                "__HQ_FBIT__=15",
                "__cpp_attributes=200809",
                "__UINT_LEAST16_MAX__=0xffffU",
                "__ATOMIC_ACQUIRE=2",
                "__SFRACT_IBIT__=0",
                "__FLT_MIN__=1.17549435e-38F",
                "__GCC_IEC_559_COMPLEX=0",
                "__BUILTIN_AVR_SLEEP=1",
                "__BUILTIN_AVR_COUNTLSULLK=1",
                "__cpp_aggregate_nsdmi=201304",
                "__BUILTIN_AVR_COUNTLSULLR=1",
                "__UFRACT_MAX__=0XFFFFP-16UR",
                "__UINT_LEAST8_TYPE__=unsigned char",
                "__DQ_FBIT__=63",
                "__INTMAX_C(c)=c ## LL",
                "__ULFRACT_FBIT__=32",
                "__SACCUM_EPSILON__=0x1P-7HK",
                "__CHAR_BIT__=8",
                "__USQ_IBIT__=0",
                "__UINT8_MAX__=0xff",
                "__ACCUM_FBIT__=15",
                "__WINT_MAX__=0x7fff",
                "__FLT32_MIN_EXP__=(-125)",
                "__cpp_static_assert=200410",
                "__USFRACT_FBIT__=8",
                "__ORDER_LITTLE_ENDIAN__=1234",
                "__SIZE_MAX__=0xffffU",
                "__WCHAR_MAX__=0x7fff",
                "__LACCUM_IBIT__=32",
                "__DBL_DENORM_MIN__=double(1.40129846e-45L)",
                "__GCC_ATOMIC_CHAR_LOCK_FREE=1",
                "__GCC_IEC_559=0",
                "__FLT_EVAL_METHOD__=0",
                "__BUILTIN_AVR_LLKBITS=1",
                "__cpp_binary_literals=201304",
                "__LLACCUM_MAX__=0X7FFFFFFFFFFFFFFFP-47LLK",
                "__GCC_ATOMIC_CHAR32_T_LOCK_FREE=1",
                "__BUILTIN_AVR_HKBITS=1",
                "__BUILTIN_AVR_BITSLLK=1",
                "__FRACT_FBIT__=15",
                "__BUILTIN_AVR_BITSLLR=1",
                "__cpp_variadic_templates=200704",
                "__UINT_FAST64_MAX__=0xffffffffffffffffULL",
                "__SIG_ATOMIC_TYPE__=char",
                "__BUILTIN_AVR_UHKBITS=1",
                "__UACCUM_FBIT__=16",
                "__DBL_MIN_10_EXP__=(-37)",
                "__FINITE_MATH_ONLY__=0",
                "__cpp_variable_templates=201304",
                "__LFRACT_IBIT__=0",
                "__GNUC_PATCHLEVEL__=0",
                "__FLT32_HAS_DENORM__=1",
                "__LFRACT_MAX__=0X7FFFFFFFP-31LR",
                "__UINT_FAST8_MAX__=0xff",
                "__has_include(STR)=__has_include__(STR)",
                "__DEC64_MAX_EXP__=385",
                "__INT8_C(c)=c",
                "__INT_LEAST8_WIDTH__=8",
                "__UINT_LEAST64_MAX__=0xffffffffffffffffULL",
                "__SA_FBIT__=15",
                "__SHRT_MAX__=0x7fff",
                "__LDBL_MAX__=3.40282347e+38L",
                "__FRACT_MAX__=0X7FFFP-15R",
                "__UFRACT_FBIT__=16",
                "__UFRACT_MIN__=0.0UR",
                "__UINT_LEAST8_MAX__=0xff",
                "__GCC_ATOMIC_BOOL_LOCK_FREE=1",
                "__UINTMAX_TYPE__=long long unsigned int",
                "__LLFRACT_EPSILON__=0x1P-63LLR",
                "__BUILTIN_AVR_DELAY_CYCLES=1",
                "__DEC32_EPSILON__=1E-6DF",
                "__FLT_EVAL_METHOD_TS_18661_3__=0",
                "__UINT32_MAX__=0xffffffffUL",
                "__GXX_EXPERIMENTAL_CXX0X__=1",
                "__ULFRACT_MAX__=0XFFFFFFFFP-32ULR",
                "__TA_IBIT__=16",
                "__LDBL_MAX_EXP__=128",
                "__WINT_MIN__=(-__WINT_MAX__ - 1)",
                "__INT_LEAST16_WIDTH__=16",
                "__ULLFRACT_MIN__=0.0ULLR",
                "__SCHAR_MAX__=0x7f",
                "__WCHAR_MIN__=(-__WCHAR_MAX__ - 1)",
                "__INT64_C(c)=c ## LL",
                "__DBL_DIG__=6",
                "__GCC_ATOMIC_POINTER_LOCK_FREE=1",
                "__AVR_HAVE_SPH__=1",
                "__LLACCUM_MIN__=(-0X1P15LLK-0X1P15LLK)",
                "__BUILTIN_AVR_KBITS=1",
                "__BUILTIN_AVR_ABSK=1",
                "__BUILTIN_AVR_ABSR=1",
                "__SIZEOF_INT__=2",
                "__SIZEOF_POINTER__=2",
                "__GCC_ATOMIC_CHAR16_T_LOCK_FREE=1",
                "__USACCUM_IBIT__=8",
                "__USER_LABEL_PREFIX__",
                "__STDC_HOSTED__=1",
                "__LDBL_HAS_INFINITY__=1",
                "__LFRACT_MIN__=(-0.5LR-0.5LR)",
                "__HA_IBIT__=8",
                "__FLT32_DIG__=6",
                "__TQ_IBIT__=0",
                "__FLT_EPSILON__=1.19209290e-7F",
                "__GXX_WEAK__=1",
                "__SHRT_WIDTH__=16",
                "__USFRACT_IBIT__=0",
                "__LDBL_MIN__=1.17549435e-38L",
                "__FRACT_MIN__=(-0.5R-0.5R)",
                "__AVR_SFR_OFFSET__=0x20",
                "__DEC32_MAX__=9.999999E96DF",
                "__cpp_threadsafe_static_init=200806",
                "__DA_IBIT__=32",
                "__INT32_MAX__=0x7fffffffL",
                "__UQQ_FBIT__=8",
                "__INT_WIDTH__=16",
                "__SIZEOF_LONG__=4",
                "__UACCUM_MAX__=0XFFFFFFFFP-16UK",
                "__UINT16_C(c)=c ## U",
                "__PTRDIFF_WIDTH__=16",
                "__DECIMAL_DIG__=9",
                "__LFRACT_EPSILON__=0x1P-31LR",
                "__AVR_2_BYTE_PC__=1",
                "__ULFRACT_MIN__=0.0ULR",
                "__INTMAX_WIDTH__=64",
                "__has_include_next(STR)=__has_include_next__(STR)",
                "__BUILTIN_AVR_ULLRBITS=1",
                "__LDBL_HAS_QUIET_NAN__=1",
                "__ULACCUM_IBIT__=32",
                "__UACCUM_EPSILON__=0x1P-16UK",
                "__BUILTIN_AVR_SEI=1",
                "__GNUC__=7",
                "__ULLACCUM_MAX__=0XFFFFFFFFFFFFFFFFP-48ULLK",
                "__cpp_delegating_constructors=200604",
                "__HQ_IBIT__=0",
                "__BUILTIN_AVR_SWAP=1",
                "__FLT_HAS_DENORM__=1",
                "__SIZEOF_LONG_DOUBLE__=4",
                "__BIGGEST_ALIGNMENT__=1",
                "__STDC_UTF_16__=1",
                "__UINT24_MAX__=16777215UL",
                "__BUILTIN_AVR_NOP=1",
                "__GNUC_STDC_INLINE__=1",
                "__DQ_IBIT__=0",
                "__FLT32_HAS_INFINITY__=1",
                "__DBL_MAX__=double(3.40282347e+38L)",
                "__ULFRACT_IBIT__=0",
                "__cpp_raw_strings=200710",
                "__INT_FAST32_MAX__=0x7fffffffL",
                "__DBL_HAS_INFINITY__=1",
                "__INT64_MAX__=0x7fffffffffffffffLL",
                "__ACCUM_IBIT__=16",
                "__DEC32_MIN_EXP__=(-94)",
                "__BUILTIN_AVR_UKBITS=1",
                "__INTPTR_WIDTH__=16",
                "__BUILTIN_AVR_FMULSU=1",
                "__LACCUM_MAX__=0X7FFFFFFFFFFFFFFFP-31LK",
                "__INT_FAST16_TYPE__=int",
                "__LDBL_HAS_DENORM__=1",
                "__BUILTIN_AVR_BITSK=1",
                "__BUILTIN_AVR_BITSR=1",
                "__cplusplus=201402L",
                "__cpp_ref_qualifiers=200710",
                "__DEC128_MAX__=9.999999999999999999999999999999999E6144DL",
                "__INT_LEAST32_MAX__=0x7fffffffL",
                "__USING_SJLJ_EXCEPTIONS__=1",
                "__DEC32_MIN__=1E-95DF",
                "__ACCUM_MAX__=0X7FFFFFFFP-15K",
                "__DEPRECATED=1",
                "__cpp_rvalue_references=200610",
                "__DBL_MAX_EXP__=128",
                "__USACCUM_EPSILON__=0x1P-8UHK",
                "__WCHAR_WIDTH__=16",
                "__FLT32_MAX__=3.40282347e+38F32",
                "__DEC128_EPSILON__=1E-33DL",
                "__SFRACT_MAX__=0X7FP-7HR",
                "__FRACT_IBIT__=0",
                "__PTRDIFF_MAX__=0x7fff",
                "__UACCUM_MIN__=0.0UK",
                "__UACCUM_IBIT__=16",
                "__BUILTIN_AVR_NOPS=1",
                "__BUILTIN_AVR_WDR=1",
                "__FLT32_HAS_QUIET_NAN__=1",
                "__GNUG__=7",
                "__LONG_LONG_MAX__=0x7fffffffffffffffLL",
                "__SIZEOF_SIZE_T__=2",
                "__ULACCUM_MAX__=0XFFFFFFFFFFFFFFFFP-32ULK",
                "__cpp_rvalue_reference=200610",
                "__cpp_nsdmi=200809",
                "__SIZEOF_WINT_T__=2",
                "__LONG_LONG_WIDTH__=64",
                "__cpp_initializer_lists=200806",
                "__FLT32_MAX_EXP__=128",
                "__SA_IBIT__=16",
                "__ULLACCUM_MIN__=0.0ULLK",
                "__BUILTIN_AVR_ROUNDUHK=1",
                "__BUILTIN_AVR_ROUNDUHR=1",
                "__cpp_hex_float=201603",
                "__GXX_ABI_VERSION=1011",
                "__INT24_MAX__=8388607L",
                "__UTA_FBIT__=48",
                "__FLT_MIN_EXP__=(-125)",
                "__USFRACT_MAX__=0XFFP-8UHR",
                "__UFRACT_IBIT__=0",
                "__BUILTIN_AVR_ROUNDFX=1",
                "__BUILTIN_AVR_ROUNDULK=1",
                "__BUILTIN_AVR_ROUNDULR=1",
                "__cpp_lambdas=200907",
                "__BUILTIN_AVR_COUNTLSLLK=1",
                "__BUILTIN_AVR_COUNTLSLLR=1",
                "__BUILTIN_AVR_ROUNDHK=1",
                "__INT_FAST64_TYPE__=long long int",
                "__BUILTIN_AVR_ROUNDHR=1",
                "__DBL_MIN__=double(1.17549435e-38L)",
                "__BUILTIN_AVR_COUNTLSK=1",
                "__BUILTIN_AVR_ROUNDLK=1",
                "__BUILTIN_AVR_COUNTLSR=1",
                "__BUILTIN_AVR_ROUNDLR=1",
                "__LACCUM_MIN__=(-0X1P31LK-0X1P31LK)",
                "__ULLACCUM_FBIT__=48",
                "__BUILTIN_AVR_LKBITS=1",
                "__ULLFRACT_EPSILON__=0x1P-64ULLR",
                "__DEC128_MIN__=1E-6143DL",
                "__REGISTER_PREFIX__",
                "__UINT16_MAX__=0xffffU",
                "__DBL_HAS_DENORM__=1",
                "__BUILTIN_AVR_ULKBITS=1",
                "__ACCUM_MIN__=(-0X1P15K-0X1P15K)",
                "__AVR_ARCH__=2",
                "__SQ_IBIT__=0",
                "__FLT32_MIN__=1.17549435e-38F32",
                "__UINT8_TYPE__=unsigned char",
                "__BUILTIN_AVR_ROUNDUK=1",
                "__BUILTIN_AVR_ROUNDUR=1",
                "__UHA_FBIT__=8",
                "__NO_INLINE__=1",
                "__SFRACT_MIN__=(-0.5HR-0.5HR)",
                "__UTQ_FBIT__=128",
                "__FLT_MANT_DIG__=24",
                "__LDBL_DECIMAL_DIG__=9",
                "__VERSION__=\"7.3.0\"",
                "__UINT64_C(c)=c ## ULL",
                "__ULLFRACT_FBIT__=64",
                "__cpp_unicode_characters=200704",
                "__FRACT_EPSILON__=0x1P-15R",
                "__ULACCUM_MIN__=0.0ULK",
                "__UDA_FBIT__=32",
                "__cpp_decltype_auto=201304",
                "__LLACCUM_EPSILON__=0x1P-47LLK",
                "__GCC_ATOMIC_INT_LOCK_FREE=1",
                "__FLT32_MANT_DIG__=24",
                "__BUILTIN_AVR_BITSUHK=1",
                "__BUILTIN_AVR_BITSUHR=1",
                "__FLOAT_WORD_ORDER__=__ORDER_LITTLE_ENDIAN__",
                "__USFRACT_MIN__=0.0UHR",
                "__BUILTIN_AVR_BITSULK=1",
                "__ULLACCUM_IBIT__=16",
                "__BUILTIN_AVR_BITSULR=1",
                "__UQQ_IBIT__=0",
                "__BUILTIN_AVR_LLRBITS=1",
                "__SCHAR_WIDTH__=8",
                "__BUILTIN_AVR_BITSULLK=1",
                "__BUILTIN_AVR_BITSULLR=1",
                "__INT32_C(c)=c ## L",
                "__DEC64_EPSILON__=1E-15DD",
                "__ORDER_PDP_ENDIAN__=3412",
                "__DEC128_MIN_EXP__=(-6142)",
                "__UHQ_FBIT__=16",
                "__LLACCUM_FBIT__=47",
                "__FLT32_MAX_10_EXP__=38",
                "__BUILTIN_AVR_ROUNDULLK=1",
                "__BUILTIN_AVR_ROUNDULLR=1",
                "__INT_FAST32_TYPE__=long int",
                "__BUILTIN_AVR_HRBITS=1",
                "__UINT_LEAST16_TYPE__=unsigned int",
                "__BUILTIN_AVR_UHRBITS=1",
                "__INT16_MAX__=0x7fff",
                "__SIZE_TYPE__=unsigned int",
                "__UINT64_MAX__=0xffffffffffffffffULL",
                "__UDQ_FBIT__=64",
                "__INT8_TYPE__=signed char",
                "__cpp_digit_separators=201309",
                "__ELF__=1",
                "__ULFRACT_EPSILON__=0x1P-32ULR",
                "__LLFRACT_FBIT__=63",
                "__FLT_RADIX__=2",
                "__INT_LEAST16_TYPE__=int",
                "__BUILTIN_AVR_ABSFX=1",
                "__LDBL_EPSILON__=1.19209290e-7L",
                "__UINTMAX_C(c)=c ## ULL",
                "__INT24_MIN__=(-__INT24_MAX__-1)",
                "__SACCUM_MAX__=0X7FFFP-7HK",
                "__BUILTIN_AVR_ABSHR=1",
                "__SIG_ATOMIC_MAX__=0x7f",
                "__GCC_ATOMIC_WCHAR_T_LOCK_FREE=1",
                "__cpp_sized_deallocation=201309",
                "__SIZEOF_PTRDIFF_T__=2",
                "__AVR=1",
                "__BUILTIN_AVR_ABSLK=1",
                "__BUILTIN_AVR_ABSLR=1",
                "__LACCUM_EPSILON__=0x1P-31LK",
                "__DEC32_SUBNORMAL_MIN__=0.000001E-95DF",
                "__INT_FAST16_MAX__=0x7fff",
                "__UINT_FAST32_MAX__=0xffffffffUL",
                "__UINT_LEAST64_TYPE__=long long unsigned int",
                "__USACCUM_MAX__=0XFFFFP-8UHK",
                "__SFRACT_EPSILON__=0x1P-7HR",
                "__FLT_HAS_QUIET_NAN__=1",
                "__FLT_MAX_10_EXP__=38",
                "__LONG_MAX__=0x7fffffffL",
                "__DEC128_SUBNORMAL_MIN__=0.000000000000000000000000000000001E-6143DL",
                "__FLT_HAS_INFINITY__=1",
                "__cpp_unicode_literals=200710",
                "__USA_FBIT__=16",
                "__UINT_FAST16_TYPE__=unsigned int",
                "__DEC64_MAX__=9.999999999999999E384DD",
                "__INT_FAST32_WIDTH__=32",
                "__BUILTIN_AVR_RBITS=1",
                "__CHAR16_TYPE__=unsigned int",
                "__PRAGMA_REDEFINE_EXTNAME=1",
                "__SIZE_WIDTH__=16",
                "__INT_LEAST16_MAX__=0x7fff",
                "__DEC64_MANT_DIG__=16",
                "__UINT_LEAST32_MAX__=0xffffffffUL",
                "__SACCUM_FBIT__=7",
                "__FLT32_DENORM_MIN__=1.40129846e-45F32",
                "__GCC_ATOMIC_LONG_LOCK_FREE=1",
                "__SIG_ATOMIC_WIDTH__=8",
                "__INT_LEAST64_TYPE__=long long int",
                "__INT16_TYPE__=int",
                "__INT_LEAST8_TYPE__=signed char",
                "__SQ_FBIT__=31",
                "__DEC32_MAX_EXP__=97",
                "__INT_FAST8_MAX__=0x7f",
                "__INTPTR_MAX__=0x7fff",
                "__QQ_FBIT__=7",
                "__cpp_range_based_for=200907",
                "__UTA_IBIT__=16",
                "__AVR_ERRATA_SKIP__=1",
                "__FLT32_MIN_10_EXP__=(-37)",
                "__LDBL_MANT_DIG__=24",
                "__SFRACT_FBIT__=7",
                "__SACCUM_MIN__=(-0X1P7HK-0X1P7HK)",
                "__DBL_HAS_QUIET_NAN__=1",
                "__SIG_ATOMIC_MIN__=(-__SIG_ATOMIC_MAX__ - 1)",
                "AVR=1",
                "__BUILTIN_AVR_FMULS=1",
                "__cpp_return_type_deduction=201304",
                "__INTPTR_TYPE__=int",
                "__UINT16_TYPE__=unsigned int",
                "__WCHAR_TYPE__=int",
                "__SIZEOF_FLOAT__=4",
                "__AVR__=1",
                "__BUILTIN_AVR_INSERT_BITS=1",
                "__USQ_FBIT__=32",
                "__UINTPTR_MAX__=0xffffU",
                "__INT_FAST64_WIDTH__=64",
                "__DEC64_MIN_EXP__=(-382)",
                "__cpp_decltype=200707",
                "__FLT32_DECIMAL_DIG__=9",
                "__INT_FAST64_MAX__=0x7fffffffffffffffLL",
                "__GCC_ATOMIC_TEST_AND_SET_TRUEVAL=1",
                "__FLT_DIG__=6",
                "__UINT_FAST64_TYPE__=long long unsigned int",
                "__BUILTIN_AVR_BITSHK=1",
                "__BUILTIN_AVR_BITSHR=1",
                "__INT_MAX__=0x7fff",
                "__LACCUM_FBIT__=31",
                "__USACCUM_MIN__=0.0UHK",
                "__UHA_IBIT__=8",
                "__INT64_TYPE__=long long int",
                "__BUILTIN_AVR_BITSLK=1",
                "__BUILTIN_AVR_BITSLR=1",
                "__FLT_MAX_EXP__=128",
                "__UTQ_IBIT__=0",
                "__DBL_MANT_DIG__=24",
                "__cpp_inheriting_constructors=201511",
                "__BUILTIN_AVR_ULLKBITS=1",
                "__INT_LEAST64_MAX__=0x7fffffffffffffffLL",
                "__DEC64_MIN__=1E-383DD",
                "__WINT_TYPE__=int",
                "__UINT_LEAST32_TYPE__=long unsigned int",
                "__SIZEOF_SHORT__=2",
                "__ULLFRACT_IBIT__=0",
                "__LDBL_MIN_EXP__=(-125)",
                "__UDA_IBIT__=32",
                "__WINT_WIDTH__=16",
                "__INT_LEAST8_MAX__=0x7f",
                "__LFRACT_FBIT__=31",
                "__LDBL_MAX_10_EXP__=38",
                "__ATOMIC_RELAXED=0",
                "__DBL_EPSILON__=double(1.19209290e-7L)",
                "__BUILTIN_AVR_BITSUK=1",
                "__BUILTIN_AVR_BITSUR=1",
                "__UINT8_C(c)=c",
                "__INT_LEAST32_TYPE__=long int",
                "__BUILTIN_AVR_URBITS=1",
                "__SIZEOF_WCHAR_T__=2",
                "__LLFRACT_MAX__=0X7FFFFFFFFFFFFFFFP-63LLR",
                "__TQ_FBIT__=127",
                "__INT_FAST8_TYPE__=signed char",
                "__ULLACCUM_EPSILON__=0x1P-48ULLK",
                "__BUILTIN_AVR_ROUNDK=1",
                "__BUILTIN_AVR_ROUNDR=1",
                "__UHQ_IBIT__=0",
                "__LLACCUM_IBIT__=16",
                "__FLT32_EPSILON__=1.19209290e-7F32",
                "__DBL_DECIMAL_DIG__=9",
                "__STDC_UTF_32__=1",
                "__INT_FAST8_WIDTH__=8",
                "__DEC_EVAL_METHOD__=2",
                "__TA_FBIT__=47",
                "__UDQ_IBIT__=0",
                "__ORDER_BIG_ENDIAN__=4321",
                "__cpp_runtime_arrays=198712",
                "__WITH_AVRLIBC__=1",
                "__UINT64_TYPE__=long long unsigned int",
                "__ACCUM_EPSILON__=0x1P-15K",
                "__UINT32_C(c)=c ## UL",
                "__BUILTIN_AVR_COUNTLSUHK=1",
                "__INTMAX_MAX__=0x7fffffffffffffffLL",
                "__cpp_alias_templates=200704",
                "__BUILTIN_AVR_COUNTLSUHR=1",
                "__BYTE_ORDER__=__ORDER_LITTLE_ENDIAN__",
                "__FLT_DENORM_MIN__=1.40129846e-45F",
                "__LLFRACT_IBIT__=0",
                "__INT8_MAX__=0x7f",
                "__LONG_WIDTH__=32",
                "__UINT_FAST32_TYPE__=long unsigned int",
                "__CHAR32_TYPE__=long unsigned int",
                "__BUILTIN_AVR_COUNTLSULK=1",
                "__BUILTIN_AVR_COUNTLSULR=1",
                "__FLT_MAX__=3.40282347e+38F",
                "__cpp_constexpr=201304",
                "__USACCUM_FBIT__=8",
                "__BUILTIN_AVR_COUNTLSFX=1",
                "__INT32_TYPE__=long int",
                "__SIZEOF_DOUBLE__=4",
                "__FLT_MIN_10_EXP__=(-37)",
                "__UFRACT_EPSILON__=0x1P-16UR",
                "__INT_LEAST32_WIDTH__=32",
                "__BUILTIN_AVR_COUNTLSHK=1",
                "__BUILTIN_AVR_COUNTLSHR=1",
                "__INTMAX_TYPE__=long long int",
                "__BUILTIN_AVR_ABSLLK=1",
                "__BUILTIN_AVR_ABSLLR=1",
                "__DEC128_MAX_EXP__=6145",
                "__AVR_HAVE_16BIT_SP__=1",
                "__ATOMIC_CONSUME=1",
                "__GNUC_MINOR__=3",
                "__INT_FAST16_WIDTH__=16",
                "__UINTMAX_MAX__=0xffffffffffffffffULL",
                "__DEC32_MANT_DIG__=7",
                "__HA_FBIT__=7",
                "__BUILTIN_AVR_COUNTLSLK=1",
                "__BUILTIN_AVR_COUNTLSLR=1",
                "__BUILTIN_AVR_CLI=1",
                "__DBL_MAX_10_EXP__=38",
                "__LDBL_DENORM_MIN__=1.40129846e-45L",
                "__INT16_C(c)=c",
                "__cpp_generic_lambdas=201304",
                "__STDC__=1",
                "__PTRDIFF_TYPE__=int",
                "__LLFRACT_MIN__=(-0.5LLR-0.5LLR)",
                "__BUILTIN_AVR_LRBITS=1",
                "__ATOMIC_SEQ_CST=5",
                "__DA_FBIT__=31",
                "__UINT32_TYPE__=long unsigned int",
                "__BUILTIN_AVR_ROUNDLLK=1",
                "__UINTPTR_TYPE__=unsigned int",
                "__BUILTIN_AVR_ROUNDLLR=1",
                "__USA_IBIT__=16",
                "__BUILTIN_AVR_ULRBITS=1",
                "__DEC64_SUBNORMAL_MIN__=0.000000000000001E-383DD",
                "__DEC128_MANT_DIG__=34",
                "__LDBL_MIN_10_EXP__=(-37)",
                "__BUILTIN_AVR_COUNTLSUK=1",
                "__BUILTIN_AVR_COUNTLSUR=1",
                "__SIZEOF_LONG_LONG__=8",
                "__ULACCUM_EPSILON__=0x1P-32ULK",
                "__cpp_user_defined_literals=200809",
                "__SACCUM_IBIT__=8",
                "__GCC_ATOMIC_LLONG_LOCK_FREE=1",
                "__LDBL_DIG__=6",
                "__FLT_DECIMAL_DIG__=9",
                "__UINT_FAST16_MAX__=0xffffU",
                "__GCC_ATOMIC_SHORT_LOCK_FREE=1",
                "__BUILTIN_AVR_ABSHK=1",
                "__BUILTIN_AVR_FLASH_SEGMENT=1",
                "__INT_LEAST64_WIDTH__=64",
                "__ULLFRACT_MAX__=0XFFFFFFFFFFFFFFFFP-64ULLR",
                "__UINT_FAST8_TYPE__=unsigned char",
                "__USFRACT_EPSILON__=0x1P-8UHR",
                "__ULACCUM_FBIT__=32",
                "__QQ_IBIT__=0",
                "__cpp_init_captures=201304",
                "__ATOMIC_ACQ_REL=4",
                "__ATOMIC_RELEASE=3",
                "__BUILTIN_AVR_FMUL=1",
                "USBCON"
            ]
        }
    ]
}

file 24: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\.vscode\desktop.ini
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\76.0.3.0\GoogleDriveFS.exe,23


file 25: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\.vscode\settings.json
{
    "cmake.configureOnOpen": true
}

file 26: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\pinout\desktop.ini
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\76.0.3.0\GoogleDriveFS.exe,23


file 27: C:\projects\black-cobra\File_Robot_RNV3-main\File_Robot_RNV3-main\Program Utama Robot (arduino)\robotRNV3_v2_02\pinout\pinout.h
#ifndef PINOUT_H_
#define PINOUT_H_

/*
 * pinout of RAMPS 1.4
 *
 * source: http://reprap.org/wiki/RAMPS_1.4
 */

//RAMPS 1.4 PINS
#define X_STEP_PIN         54
#define X_DIR_PIN          55
#define X_ENABLE_PIN       38
#define X_MIN_PIN           3
#define X_MAX_PIN           2
 
#define Y_STEP_PIN         60
#define Y_DIR_PIN          61
#define Y_ENABLE_PIN       56
#define Y_MIN_PIN          14
#define Y_MAX_PIN          15

#define Z_STEP_PIN         46
#define Z_DIR_PIN          48
#define Z_ENABLE_PIN       62
#define Z_MIN_PIN          18
#define Z_MAX_PIN          19

#define E0_STEP_PIN        26
#define E0_DIR_PIN         28
#define E0_ENABLE_PIN      24
#define E0_MIN_PIN         20

#define E1_STEP_PIN        36
#define E1_DIR_PIN         34
#define E1_ENABLE_PIN      30
#define E1_MIN_PIN         41
#define E1_MAX_PIN         43

#define BYJ_PIN_0          40
#define BYJ_PIN_1          63
#define BYJ_PIN_2          59
#define BYJ_PIN_3          64

#define SERVO_PIN           4
#define SERVO_PIN_A         5

#define LG1_PIN            8
#define LG2_PIN            9
#define LG3_PIN            10

#define LED_PIN            13

#define SDPOWER            -1
#define SDSS               53

#define FAN_PIN            22

#define PS_ON_PIN          12
#define KILL_PIN           -1

#define IO1_PIN            16
#define IO2_PIN            17
#define IO3_PIN            57
#define IO4_PIN            25
#define IO5_PIN            27
#define IO6_PIN            29
#define IO7_PIN            31
#define IO8_PIN            33
#define IO9_PIN            35
#define IO10_PIN           37

//#define HEATER_0_PIN       10
//#define HEATER_1_PIN        8
#define TEMP_0_PIN         13   // ANALOG NUMBERING
#define TEMP_1_PIN         14   // ANALOG NUMBERING

//RAMPS AUX-2


#endif


